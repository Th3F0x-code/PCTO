{"version":3,"sources":["webpack://Matic/webpack/bootstrap","webpack://Matic/./src/implementation/bn.ts","webpack://Matic/./src/utils/use.ts","webpack://Matic/./src/utils/event_bus.ts","webpack://Matic/./src/utils/logger.ts","webpack://Matic/./src/utils/merge.ts","webpack://Matic/./src/utils/map_promise.ts","webpack://Matic/./src/utils/merkle_tree.ts","webpack://Matic/./src/utils/proof_util.ts","webpack://Matic/./src/utils/http_request.ts","webpack://Matic/./src/utils/converter.ts","webpack://Matic/./src/utils/web3_side_chain_client.ts","webpack://Matic/./src/utils/promise_resolve.ts","webpack://Matic/./src/utils/base_token.ts","webpack://Matic/./src/utils/set_proof_api_url.ts","webpack://Matic/./src/utils/resolve.ts","webpack://Matic/./src/utils/bridge_client.ts","webpack://Matic/./src/utils/abi_manager.ts","webpack://Matic/./src/utils/not_implemented.ts","webpack://Matic/./src/utils/index.ts","webpack://Matic/./src/index.ts","webpack://Matic/external \"ethereumjs-util\"","webpack://Matic/./src/enums/log_event_signature.ts","webpack://Matic/./src/enums/error_type.ts","webpack://Matic/./src/services/abi_service.ts","webpack://Matic/./src/services/network_service.ts","webpack://Matic/./src/services/index.ts","webpack://Matic/./src/config.ts","webpack://Matic/./src/utils/error_helper.ts","webpack://Matic/./node_modules/safe-buffer/index.js","webpack://Matic/./src/pos/pos_token.ts","webpack://Matic/./src/pos/erc20.ts","webpack://Matic/./src/pos/root_chain_manager.ts","webpack://Matic/./src/pos/exit_util.ts","webpack://Matic/./src/pos/root_chain.ts","webpack://Matic/./src/pos/erc721.ts","webpack://Matic/./src/pos/erc1155.ts","webpack://Matic/./src/pos/index.ts","webpack://Matic/./src/abstracts/contract_method.ts","webpack://Matic/./src/abstracts/base_web3_client.ts","webpack://Matic/./src/abstracts/base_contract.ts","webpack://Matic/./src/abstracts/base_big_number.ts","webpack://Matic/./src/default.ts","webpack://Matic/external \"merkle-patricia-tree\"","webpack://Matic/external \"ethereumjs-tx\"","webpack://Matic/./node_modules/ethereumjs-common/dist/index.js","webpack://Matic/./node_modules/ethereumjs-block/header.js","webpack://Matic/./src/interfaces/index.ts","webpack://Matic/./src/types/index.ts","webpack://Matic/./src/constant.ts","webpack://Matic/./node_modules/ethereumjs-block/from-rpc.js","webpack://Matic/external \"buffer\"","webpack://Matic/./node_modules/ethereumjs-block/index.js","webpack://Matic/./node_modules/ethereumjs-common/dist/chains/index.js","webpack://Matic/./node_modules/ethereumjs-common/dist/hardforks/index.js","webpack://Matic/./node_modules/async/dist/async.js","webpack://Matic/(webpack)/buildin/module.js","webpack://Matic/./node_modules/ethereumjs-block/header-from-rpc.js","webpack://Matic/external \"node-fetch\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","toString","base","toNumber","toBuffer","add","sub","mul","div","lte","lt","gte","gt","eq","use","plugin","pluginInstance","setup","payload","eventBusPromise","executor","promise","Promise","eventBus","EventBus","on","emit","ctx","_events","this","_ctx","event","cb","push","off","index","indexOf","splice","events","all","map","result","args","then","resolve","destroy","enableLog","isEnabled","log","console","message","error","type","info","merge","assign","obj","mapPromise","values","converter","option","valuesLength","length","concurrency","limitPromiseRun","promises","maps","val","runPromises","promiseResult","concat","utils","sha3","keccak256","leaves","Error","depth","Math","ceil","Array","from","pow","zeros","layers","createHashes","nodes","treeLevel","left","right","data","getLeaves","getLayers","getRoot","getProof","leaf","compare","proof","siblingIndex","floor","verify","root","isArray","hash","node","TRIE","rlp","getFastMerkleProof","web3","blockNumber","startBlock","endBlock","merkleTreeDepth","log2","reversedProof","targetIndex","offset","leftBound","rightBound","nLeaves","pivotLeaf","newLeftBound","queryRootHash","subTreeMerkleRoot","newRightBound","min","expectedHeight","recursiveZeroHash","subTreeHeight","heightDifference","remainingNodesHash","reverse","buildBlockProof","maticWeb3","ProofUtil","bufferToHex","Buffer","client","getRootHash","rootHash","catch","_","subHash","encodeParameters","getReceiptProof","receipt","block","requestConcurrency","receiptsVal","receiptPromise","stateSyncTxHash","getStateSyncTxHash","receiptsTrie","transactions","forEach","tx","transactionHash","getTransactionReceipt","receipts","siblingReceipt","path","encode","transactionIndex","rawReceipt","getReceiptBytes","reject","put","err","findPath","rawReceiptNode","reminder","stack","prf","blockHash","parentNodes","raw","getRawHeader","receiptTrie","isTypedReceipt","decode","hexType","toHex","status","setLengthLeft","number","encodedData","undefined","cumulativeGasUsed","logsBloom","logs","address","topics","_block","difficulty","header","fetch","default","baseUrl","url","query","keys","encodeURIComponent","join","method","headers","res","json","post","body","JSON","stringify","amount","dataType","BN","slice","isBN","logger","init","config","parent","defaultConfig","child","Web3Client","provider","network","version","abiManager","getABI","getConfig","isEIP1559Supported","isParent","promiseResolve","contractParam","getContract","contract_","bridgeType","abi","getContract_","tokenAddress","processWrite","validateTxOption_","createTransactionConfig","txConfig","isWrite","returnTransaction","encodeABI","to","write","sendTransaction","getClient","readTransaction","read","TransactionOptionNotObject","throw","processRead","parentDefaultConfig","childDefaultConfig","maxFeePerGas","maxPriorityFeePerGas","EIP1559NotSupported","gasLimit","estimateGas","nonce","getTransactionCount","chainId","getChainId","Number","transferERC20","contract","transferERC721","tokenId","checkForRoot","methodName","AllowedOnRoot","checkForChild","AllowedOnChild","transferERC1155","param","setProofApi","split","reduce","prev","curr","isCheckPointed","txHash","exitUtil","isDeposited","depositTxHash","token","lastStateId","targetLog","find","q","rootStateId","decodeParameters","rootStateIdBN","cache","networkName","getAddress","contractName","targetBridgeABICache","abiForContract","setABI","abiStore","throwNotImplemented","require","Log_Event_Signature","ERROR_TYPE","httpRequest","createUrl","getBlockIncluded","headerBlockNumber","decimalHeaderBlockNumber","parseInt","start","end","service","getMsg_","errMsg","ProofAPINotSet","BurnTxNotCheckPointed","NullSpenderAddress","Unknown","buffer","copyProps","src","dst","SafeBuffer","arg","encodingOrOffset","alloc","allocUnsafe","allocUnsafeSlow","TypeError","size","fill","encoding","buf","SlowBuffer","getPOSContracts","rootChainManager","getPredicateAddress","predicateAddress","tokenType","typeToPredicateMethod","isWithdrawn","eventSignature","getExitHash","exitHash","isExitProcessed","withdrawExitPOS","burnTxHash","isFast","buildPayloadForExit","exit","getContracts","getBalance","userAddress","getAllowance","spenderAddress","predicatePromise","approve","approveMax","deposit","amountInABI","depositEther_","withdrawStart","withdrawExit","burnTransactionHash","Erc20Transfer","withdrawExitFaster","isWithdrawExited","transfer","client_","depositData","exitPayload","rootChain","maticClient_","getLogIndex_","logEventSig","logIndex","findIndex","toLowerCase","getChainBlockInfo","getLastChildBlock","getTransaction","lastChildBlock","txBlockNumber","isCheckPointed_","getRootBlockInfo","rootBlockNumber","findRootBlockFromChild","rootBlockInfo","getRootBlockInfoFromAPI","headerBlock","getBlockProof","getBlockProofFromAPI","blockProof","blockInfo","getBlockWithTransaction","rootBlockInfoResult","blockProofResult","receiptProof","encodePayload_","timestamp","transactionsRoot","receiptsRoot","headerNumber","receiptParentNodes","blockResult","nibbleArr","byte","etheriumSha3","childBlockNumber","bigOne","bigtwo","checkPointInterval","currentHeaderBlock","ans","mid","headerStart","headerEnd","validateMany_","tokenIds","getTokensCount","options","count","getTokenIdAtIndexForUser","getAllTokens","limit","isApproved","isApprovedAll","approveAll","depositMany","tokensInHex","withdrawStartWithMetaData","withdrawStartMany","Erc721Transfer","withdrawExitWithMetaData","Erc721TransferWithMetadata","withdrawExitMany","Erc721BatchTransfer","withdrawExitFasterMany","withdrawExitFasterWithMetaData","isWithdrawWithMetaDataExited","isWithdrawExitedMany","erc1155","getAddress_","addresses","addressConfig","approveAll_","predicateAddressPromise","approveAllForMintable","amounts","emptyHex","a","amountsInHex","Erc1155Transfer","Erc1155BatchTransfer","mainPOSContracts","RootChainManagerProxy","mainPlasmaContracts","RootChainProxy","RootChainManager","erc20","getContracts_","erc721","depositEther","sendRPCRequest","jsonrpc","params","id","Date","getTime","String","defaultExport","POSClient","__assign","arguments","apply","chains_1","hardforks_1","Common","chain","hardfork","supportedHardforks","_chainParams","setChain","_hardfork","_supportedHardforks","setHardfork","forCustomChain","baseChain","customChainParams","standardChainParams","_getChainParams","chains","_i","required_1","_isSupportedHardfork","changed","hardforkChanges_1","hardforks","_chooseHardfork","onlySupported","_getHardfork","hfs_1","hf","chainName","_a","topic","hardforkChanges_2","hfChanges","v","paramByBlock","activeHfs","activeHardforks","hardforkIsActiveOnBlock","opts","hfBlock","hardforkBlock","activeOnBlock","hardforkGteHardfork","hardfork1","hardfork2","onlyActive","posHf1","posHf2","hardforks_2","gteHardfork","hardforkIsActiveOnChain","hfs_2","activeHardfork","isHardforkBlock","consensus","finality","genesis","bootstrapNodes","networkId","BlockHeader","common","_common","fields","SHA3_RLP_ARRAY","SHA3_RLP","intToBuffer","empty","allowZero","defineProperties","canonicalDifficulty","parentBlock","bufferToInt","blockTs","parentTs","parentDif","minimumDifficulty","cutoff","dif","num","uncleAddend","uncleHash","equals","idivn","ineg","iaddn","cmp","isubn","ltn","addn","exp","isNeg","iadd","validateDifficulty","validateGasLimit","pGasLimit","maxGasLimit","minGasLimit","validate","blockchain","height","self","isGenesis","getBlock","parentHash","cmpn","extraData","rlphash","setGenesisParams","stateRoot","MAX_AMOUNT","Transaction","ethUtil","Block","blockHeaderFromRpc","blockParams","uncles","uncleHeaders","_txParams","txParams","gas","input","normalizeTxParams","fromAddress","_from","getSenderAddress","uncleParams","Tx","Trie","async","rawTransactions","rawUncleHeaders","_inBlockChain","txTrie","serialize","isBuffer","_homestead","arrayToString","array","str","e","Header","rlpEncode","uncle","genTxTrie","eachSeries","done","validateTransactionsTrie","txT","transactionsTrie","validateTransactions","stringError","errors","blockChain","parallel","validateUncles","txErrors","validateUnclesHash","uncleHashes","Set","each","cb2","cb3","getDetails","isUncle","toJSON","labeled","uh","baToJSON","names","mainnet","ropsten","rinkeby","kovan","goerli","arrayLike","newLen","max","newArr","idx","fn","callArgs","initialParams","callback","pop","isObject","hasSetImmediate","setImmediate","hasNextTick","process","nextTick","fallback","setTimeout","wrap","defer","setImmediate$1","asyncify","func","invokeCallback","rethrow","supportsSymbol","isAsync","wrapAsync","asyncFn","applyEach$1","eachfn","fns","go","that","freeGlobal","global","freeSelf","Function","Symbol$1","objectProto","nativeObjectToString","symToStringTag$1","nativeObjectToString$1","symToStringTag","baseGetTag","isOwn","tag","unmasked","getRawTag","objectToString","isLength","isArrayLike","isFunction","breakLoop","noop","once","callFn","iteratorSymbol","iterator","isObjectLike","baseIsArguments","objectProto$3","hasOwnProperty$2","propertyIsEnumerable","isArguments","freeExports","nodeType","freeModule","reIsUint","isIndex","test","typedArrayTags","freeExports$1","freeModule$1","freeProcess","nodeUtil","types","binding","nodeIsTypedArray","isTypedArray","hasOwnProperty$1","arrayLikeKeys","inherited","isArr","isArg","isBuff","isType","skipIndexes","iteratee","baseTimes","objectProto$5","nativeKeys","transform","overArg","hasOwnProperty$3","baseKeys","Ctor","constructor","coll","len","createArrayIterator","okeys","getIterator","item","next","createES2015Iterator","onlyOnce","_eachOfLimit","nextElem","running","looping","iterateeCallback","replenish","elem","eachOfLimit","doLimit","iterable","eachOfArrayLike","completed","iteratorCallback","eachOfGeneric","Infinity","eachOf","doParallel","_asyncMap","arr","results","counter","_iteratee","applyEach","doParallelLimit","mapLimit","mapSeries","applyEachSeries","arrayEach","fromRight","baseFor","keysFunc","props","baseForOwn","baseIsNaN","baseIndexOf","fromIndex","strictIndexOf","predicate","baseFindIndex","auto","tasks","numTasks","runningTasks","hasError","listeners","readyTasks","readyToCheck","uncheckedDependencies","enqueueTask","task","taskCallback","safeResults","rkey","taskComplete","taskFn","runTask","processQueue","shift","run","taskName","getDependents","dependencies","remainingDependencies","dependencyName","taskListeners","currentTask","dependent","checkForDeadlocks","arrayMap","symbolProto","symbolToString","baseToString","isSymbol","castSlice","baseSlice","reHasUnicode","RegExp","rsAstral","rsCombo","rsFitz","rsNonAstral","rsRegional","rsSurrPair","reOptMod","rsModifier","rsSeq","rsSymbol","reUnicode","stringToArray","string","hasUnicode","match","unicodeToArray","asciiToArray","reTrim","trim","chars","guard","replace","strSymbols","chrSymbols","charsStartIndex","charsEndIndex","FN_ARGS","FN_ARG_SPLIT","FN_ARG","STRIP_COMMENTS","autoInject","newTasks","fnIsAsync","hasNoDeps","newTask","parseParams","taskCb","newArgs","DLL","head","tail","setInitial","dll","queue","worker","_worker","numRunning","workersList","processingScheduled","_insert","insertAtFront","started","idle","drain","_tasks","unshift","_next","unsaturated","isProcessing","saturated","paused","kill","remove","testFn","pause","resume","cargo","removeLink","insertAfter","newNode","insertBefore","toArray","eachOfSeries","memo","x","seq","_functions","newargs","nextargs","compose","_concat","concatLimit","mapResults","concatSeries","constant","identity","_createTester","check","getResult","testResult","testPassed","_findGetResult","detect","detectLimit","detectSeries","consoleFunc","dir","doDuring","_fn","_test","truth","doWhilst","doUntil","during","_withoutIndex","eachLimit","eachLimit$1","ensureAsync","sync","innerArgs","notId","every","everyLimit","everySeries","baseProperty","filterArray","truthValues","filterGeneric","sort","b","_filter","filter","filterLimit","filterSeries","forever","errback","groupByLimit","groupBy","groupBySeries","mapValuesLimit","newObj","mapValues","mapValuesSeries","has","memoize","hasher","queues","memoized","unmemoized","_parallel","parallelLimit","parallelLimit$1","queue$1","items","priorityQueue","priority","nextNode","race","reduceRight","reflect","reflectCallback","cbArg","reflectAll","reject$1","rejectLimit","rejectSeries","constant$1","retry","DEFAULT_TIMES","DEFAULT_INTERVAL","times","intervalFunc","parseTimes","acc","interval","errorFilter","_task","attempt","retryAttempt","retryable","series","some","Boolean","someLimit","someSeries","sortBy","comparator","criteria","timeout","milliseconds","timer","timedOut","clearTimeout","code","nativeCeil","nativeMax","timeLimit","step","baseRange","timesSeries","accumulator","k","tryEach","unmemoize","whilst","until","waterfall","taskIndex","nextTask","timesLimit","allLimit","allSeries","any","anyLimit","anySeries","findLimit","findSeries","forEachSeries","forEachLimit","forEachOf","forEachOfSeries","forEachOfLimit","inject","foldl","foldr","select","selectLimit","selectSeries","wrapSync","factory","webpackPolyfill","deprecate","paths","children","blockHeader","sha3Uncles","coinbase","miner","receiptRoot","SHA3_NULL","bloom","gasUsed","mixHash"],"mappings":"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","file":"matic.node.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { throwNotImplemented } from \"..\";\nimport { BaseBigNumber } from \"../abstracts\";\n\nexport class EmptyBigNumber extends BaseBigNumber {\n\n    constructor(value) {\n        super();\n    }\n\n    toString(base?) {\n        return throwNotImplemented<string>();\n    }\n\n    toNumber() {\n        return throwNotImplemented<number>();\n    }\n\n    toBuffer(base?) {\n        return throwNotImplemented<Buffer>();\n    }\n\n    add(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    sub(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    mul(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    div(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    lte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n\n    lt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    eq(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n}","import { IPlugin } from \"../interfaces\";\nimport { defaultExport } from \"../default\";\n\nexport const use = (plugin, ...payload) => {\n    const pluginInstance: IPlugin = typeof plugin === \"function\" ? new plugin() : plugin;\n    return pluginInstance.setup(defaultExport, ...payload);\n};","export interface IEventBusPromise<T> extends Promise<T> {\n    on(event: string, cb: Function);\n    emit(event: string, ...args);\n    destroy();\n}\n\nexport const eventBusPromise = function <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) {\n    const promise: IEventBusPromise<T> = new Promise(executor) as any;\n    const eventBus = new EventBus();\n    promise.on = eventBus.on.bind(eventBus);\n    promise.emit = eventBus.emit.bind(eventBus);\n    return promise;\n};\n\nexport class EventBus {\n\n    constructor(ctx?) {\n        this._ctx = ctx;\n    }\n\n    private _ctx;\n\n    private _events: {\n        [key: string]: Function[]\n    } = {};\n\n    on(event: string, cb: Function) {\n        if (this._events[event] == null) {\n            this._events[event] = [];\n        }\n        this._events[event].push(cb);\n        return this;\n    }\n\n    off(event: string, cb: Function) {\n        if (this._events[event]) {\n            if (cb) {\n                const index = this._events[event].indexOf(cb);\n                this._events[event].splice(index, 1);\n            }\n            else {\n                this._events[event] = [];\n            }\n        }\n    }\n\n    emit(event: string, ...args) {\n        const events = this._events[event] || [];\n        return Promise.all(\n            events.map(cb => {\n                const result = cb.call(this._ctx, ...args);\n                return result && result.then ? result : Promise.resolve(result);\n            })\n        );\n    }\n\n    destroy() {\n        this._events = null;\n        this._ctx = null;\n    }\n}","import { ERROR_TYPE } from \"../enums\";\nimport { ErrorHelper } from \"./error_helper\";\n\nexport class Logger {\n\n    private isEnabled: boolean;\n\n    enableLog(value) {\n        this.isEnabled = value ? true : false;\n    }\n\n    log(...message) {\n        if (this.isEnabled) {\n            console.log(...message);\n        }\n    }\n\n    error(type: ERROR_TYPE, info?) {\n        return new ErrorHelper(type, info);\n    }\n}","export const merge = (...obj) => {\n    return Object.assign({}, ...obj);\n};","import { promiseResolve } from '..';\nimport { IMapPromiseOption } from '../interfaces';\n\nconst runPromises = (promises: Array<Promise<any>>, converter: Function) => {\n  const maps = promises.map((val, index) => {\n    return converter(val, index);\n  });\n  return Promise.all(maps);\n};\n\nexport function mapPromise(values: any[], converter: Function, option: IMapPromiseOption = {} as any) {\n  const valuesLength = values.length;\n  const concurrency = option.concurrency || valuesLength;\n\n  let result = [];\n  const limitPromiseRun: () => Promise<any> = () => {\n    const promises = values.splice(0, concurrency);\n    return runPromises(promises, converter).then(promiseResult => {\n      result = result.concat(promiseResult);\n\n      return valuesLength > result.length ?\n        limitPromiseRun() : promiseResolve(result);\n    });\n  };\n\n  return limitPromiseRun();\n}\n","const utils = require('ethereumjs-util');\n// const SafeBuffer = require('safe-buffer').Buffer;\nconst sha3 = utils.keccak256;\n\nimport { Buffer as SafeBuffer } from \"safe-buffer\";\n\nexport class MerkleTree {\n    leaves: any;\n    layers: any;\n\n    constructor(leaves = []) {\n        if (leaves.length < 1) {\n            throw new Error('Atleast 1 leaf needed');\n        }\n\n        const depth = Math.ceil(Math.log(leaves.length) / Math.log(2));\n        if (depth > 20) {\n            throw new Error('Depth must be 20 or less');\n        }\n\n        this.leaves = leaves.concat(\n            Array.from(\n                // tslint:disable-next-line\n                Array(Math.pow(2, depth) - leaves.length),\n                () => utils.zeros(32)\n            )\n        );\n        this.layers = [this.leaves];\n        this.createHashes(this.leaves);\n    }\n\n    createHashes(nodes) {\n        if (nodes.length === 1) {\n            return false;\n        }\n\n\n        const treeLevel = [];\n        for (let i = 0; i < nodes.length; i += 2) {\n            const left = nodes[i];\n            const right = nodes[i + 1];\n\n            const data = SafeBuffer.concat([left, right]);\n            treeLevel.push(sha3(data));\n        }\n\n        // is odd number of nodes\n        if (nodes.length % 2 === 1) {\n            treeLevel.push(nodes[nodes.length - 1]);\n        }\n\n        this.layers.push(treeLevel);\n        this.createHashes(treeLevel);\n    }\n\n    getLeaves() {\n        return this.leaves;\n    }\n\n    getLayers() {\n        return this.layers;\n    }\n\n    getRoot() {\n        return this.layers[this.layers.length - 1][0];\n    }\n\n    getProof(leaf) {\n        let index = -1;\n        for (let i = 0; i < this.leaves.length; i++) {\n            if (SafeBuffer.compare(leaf, this.leaves[i]) === 0) {\n                index = i;\n            }\n        }\n\n        const proof = [];\n        if (index <= this.getLeaves().length) {\n            let siblingIndex;\n            for (let i = 0; i < this.layers.length - 1; i++) {\n                if (index % 2 === 0) {\n                    siblingIndex = index + 1;\n                } else {\n                    siblingIndex = index - 1;\n                }\n                index = Math.floor(index / 2);\n                proof.push(this.layers[i][siblingIndex]);\n            }\n        }\n        return proof;\n    }\n\n    verify(value, index, root, proof) {\n        if (!Array.isArray(proof) || !value || !root) {\n            return false;\n        }\n\n        let hash = value;\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            if (index % 2 === 0) {\n                hash = sha3(SafeBuffer.concat([hash, node]));\n            } else {\n                hash = sha3(SafeBuffer.concat([node, hash]));\n            }\n\n            index = Math.floor(index / 2);\n        }\n\n        return SafeBuffer.compare(hash, root) === 0;\n    }\n}\n\n","import { BaseWeb3Client } from \"../abstracts\";\nimport { MerkleTree } from \"./merkle_tree\";\nimport ethUtils from \"ethereumjs-util\";\nimport { ITransactionReceipt, IBlock, IBlockWithTransaction } from \"../interfaces\";\nimport { mapPromise } from \"./map_promise\";\nconst TRIE = require('merkle-patricia-tree');\nconst rlp = ethUtils.rlp;\nimport EthereumBlock from 'ethereumjs-block/from-rpc';\nimport { Converter, promiseResolve, utils } from \"..\";\n\n// Implementation adapted from Tom French's `matic-proofs` library used under MIT License\n// https://github.com/TomAFrench/matic-proofs\n\nexport class ProofUtil {\n\n    static async getFastMerkleProof(\n        web3: BaseWeb3Client,\n        blockNumber: number,\n        startBlock: number,\n        endBlock: number\n    ): Promise<string[]> {\n        const merkleTreeDepth = Math.ceil(Math.log2(endBlock - startBlock + 1));\n\n        // We generate the proof root down, whereas we need from leaf up\n        const reversedProof: string[] = [];\n\n        const offset = startBlock;\n        const targetIndex = blockNumber - offset;\n        let leftBound = 0;\n        let rightBound = endBlock - offset;\n        //   console.log(\"Searching for\", targetIndex);\n        for (let depth = 0; depth < merkleTreeDepth; depth += 1) {\n            const nLeaves = 2 ** (merkleTreeDepth - depth);\n\n            // The pivot leaf is the last leaf which is included in the left subtree\n            const pivotLeaf = leftBound + nLeaves / 2 - 1;\n\n            if (targetIndex > pivotLeaf) {\n                // Get the root hash to the merkle subtree to the left\n                const newLeftBound = pivotLeaf + 1;\n                // eslint-disable-next-line no-await-in-loop\n                const subTreeMerkleRoot = await this.queryRootHash(web3, offset + leftBound, offset + pivotLeaf);\n                reversedProof.push(subTreeMerkleRoot);\n                leftBound = newLeftBound;\n            } else {\n                // Things are more complex when querying to the right.\n                // Root hash may come some layers down so we need to build a full tree by padding with zeros\n                // Some trees may be completely empty\n\n                const newRightBound = Math.min(rightBound, pivotLeaf);\n\n                // Expect the merkle tree to have a height one less than the current layer\n                const expectedHeight = merkleTreeDepth - (depth + 1);\n                if (rightBound <= pivotLeaf) {\n                    // Tree is empty so we repeatedly hash zero to correct height\n                    const subTreeMerkleRoot = this.recursiveZeroHash(expectedHeight, web3);\n                    reversedProof.push(subTreeMerkleRoot);\n                } else {\n                    // Height of tree given by RPC node\n                    const subTreeHeight = Math.ceil(Math.log2(rightBound - pivotLeaf));\n\n                    // Find the difference in height between this and the subtree we want\n                    const heightDifference = expectedHeight - subTreeHeight;\n\n                    // For every extra layer we need to fill 2*n leaves filled with the merkle root of a zero-filled Merkle tree\n                    // We need to build a tree which has heightDifference layers\n\n                    // The first leaf will hold the root hash as returned by the RPC\n                    // eslint-disable-next-line no-await-in-loop\n                    const remainingNodesHash = await this.queryRootHash(web3, offset + pivotLeaf + 1, offset + rightBound);\n\n                    // The remaining leaves will hold the merkle root of a zero-filled tree of height subTreeHeight\n                    const leafRoots = this.recursiveZeroHash(subTreeHeight, web3);\n\n                    // Build a merkle tree of correct size for the subtree using these merkle roots\n                    const leaves = Array.from({ length: 2 ** heightDifference }, () => ethUtils.toBuffer(leafRoots));\n                    leaves[0] = remainingNodesHash;\n                    const subTreeMerkleRoot = new MerkleTree(leaves).getRoot();\n                    reversedProof.push(subTreeMerkleRoot);\n                }\n                rightBound = newRightBound;\n            }\n        }\n\n        return reversedProof.reverse();\n    }\n\n    static buildBlockProof(maticWeb3: BaseWeb3Client, startBlock: number, endBlock: number, blockNumber: number) {\n        return ProofUtil.getFastMerkleProof(\n            maticWeb3, blockNumber, startBlock, endBlock\n        ).then(proof => {\n            return ethUtils.bufferToHex(\n                Buffer.concat(\n                    proof.map(p => {\n                        return ethUtils.toBuffer(p);\n                    })\n                )\n            );\n        });\n    }\n\n    static queryRootHash(client: BaseWeb3Client, startBlock: number, endBlock: number) {\n        return client.getRootHash(startBlock, endBlock).then(rootHash => {\n            return ethUtils.toBuffer(`0x${rootHash}`);\n        }).catch(_ => {\n            return null;\n        });\n    }\n\n    static recursiveZeroHash(n: number, client: BaseWeb3Client) {\n        if (n === 0) return '0x0000000000000000000000000000000000000000000000000000000000000000';\n        const subHash = this.recursiveZeroHash(n - 1, client);\n        return ethUtils.keccak256(\n            ethUtils.toBuffer(client.encodeParameters([subHash, subHash], ['bytes32', 'bytes32'],))\n        );\n    }\n\n    static getReceiptProof(receipt: ITransactionReceipt, block: IBlockWithTransaction, web3: BaseWeb3Client, requestConcurrency = Infinity, receiptsVal?: ITransactionReceipt[]) {\n        const stateSyncTxHash = ethUtils.bufferToHex(ProofUtil.getStateSyncTxHash(block));\n        const receiptsTrie = new TRIE();\n        let receiptPromise: Promise<ITransactionReceipt[]>;\n        if (!receiptsVal) {\n            const receiptPromises = [];\n            block.transactions.forEach(tx => {\n                if (tx.transactionHash === stateSyncTxHash) {\n                    // ignore if tx hash is bor state-sync tx\n                    return;\n                }\n                receiptPromises.push(\n                    web3.getTransactionReceipt(tx.transactionHash)\n                );\n            });\n            receiptPromise = mapPromise(\n                receiptPromises,\n                val => {\n                    return val;\n                },\n                {\n                    concurrency: requestConcurrency,\n                }\n            );\n        }\n        else {\n            receiptPromise = promiseResolve(receiptsVal);\n        }\n\n        return receiptPromise.then(receipts => {\n            return Promise.all(\n                receipts.map(siblingReceipt => {\n                    const path = rlp.encode(siblingReceipt.transactionIndex);\n                    const rawReceipt = ProofUtil.getReceiptBytes(siblingReceipt);\n                    return new Promise((resolve, reject) => {\n                        receiptsTrie.put(path, rawReceipt, err => {\n                            if (err) {\n                                reject(err);\n                            } else {\n                                resolve({});\n                            }\n                        });\n                    });\n                })\n            );\n        }).then(_ => {\n            // promise\n            return new Promise((resolve, reject) => {\n                receiptsTrie.findPath(rlp.encode(receipt.transactionIndex), (err, rawReceiptNode, reminder, stack) => {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    if (reminder.length > 0) {\n                        return reject(new Error('Node does not contain the key'));\n                    }\n\n                    const prf = {\n                        blockHash: ethUtils.toBuffer(receipt.blockHash),\n                        parentNodes: stack.map(s => s.raw),\n                        root: ProofUtil.getRawHeader(block).receiptTrie,\n                        path: rlp.encode(receipt.transactionIndex),\n                        value: ProofUtil.isTypedReceipt(receipt) ? rawReceiptNode.value : rlp.decode(rawReceiptNode.value)\n                    };\n                    resolve(prf);\n                });\n            });\n        });\n    }\n\n    static isTypedReceipt(receipt: ITransactionReceipt) {\n        const hexType = Converter.toHex(receipt.type);\n        return receipt.status != null && hexType !== \"0x0\" && hexType !== \"0x\";\n    }\n\n    // getStateSyncTxHash returns block's tx hash for state-sync receipt\n    // Bor blockchain includes extra receipt/tx for state-sync logs,\n    // but it is not included in transactionRoot or receiptRoot.\n    // So, while calculating proof, we have to exclude them.\n    //\n    // This is derived from block's hash and number\n    // state-sync tx hash = keccak256(\"matic-bor-receipt-\" + block.number + block.hash)\n    static getStateSyncTxHash(block): Buffer {\n        return ethUtils.keccak256(\n            Buffer.concat([\n                ethUtils.toBuffer('matic-bor-receipt-'), // prefix for bor receipt\n                ethUtils.setLengthLeft(ethUtils.toBuffer(block.number), 8), // 8 bytes of block number (BigEndian)\n                ethUtils.toBuffer(block.hash), // block hash\n            ])\n        );\n    }\n\n    static getReceiptBytes(receipt: ITransactionReceipt) {\n        let encodedData = rlp.encode([\n            ethUtils.toBuffer(\n                receipt.status !== undefined && receipt.status != null ? (receipt.status ? '0x1' : '0x') : receipt.root\n            ),\n            ethUtils.toBuffer(receipt.cumulativeGasUsed),\n            ethUtils.toBuffer(receipt.logsBloom),\n            // encoded log array\n            receipt.logs.map(l => {\n                // [address, [topics array], data]\n                return [\n                    ethUtils.toBuffer(l.address), // convert address to buffer\n                    l.topics.map(ethUtils.toBuffer), // convert topics to buffer\n                    ethUtils.toBuffer(l.data), // convert data to buffer\n                ];\n            }),\n        ]);\n        if (ProofUtil.isTypedReceipt(receipt)) {\n            encodedData = Buffer.concat([ethUtils.toBuffer(receipt.type), encodedData]);\n        }\n        return encodedData;\n    }\n\n    static getRawHeader(_block) {\n        if (typeof _block.difficulty !== 'string') {\n            _block.difficulty = '0x' + _block.difficulty.toString(16);\n        }\n        const block = new EthereumBlock(_block);\n        return block.header;\n    }\n}\n","const fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n    (() => {\n        if (process.env.BUILD_ENV === \"node\") {\n            return require('node-fetch').default;\n        }\n        return window.fetch;\n    })();\n\n\nexport class HttpRequest {\n    baseUrl = \"\";\n\n    constructor(option: { baseUrl: string } | string = {} as any) {\n        option = typeof option === \"string\" ? {\n            baseUrl: option\n        } : option;\n\n        if (option.baseUrl) {\n            this.baseUrl = option.baseUrl;\n        }\n    }\n\n    get<T>(url = \"\", query = {}): Promise<T> {\n        url = this.baseUrl + url + Object.keys(query).\n            map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n\n        return fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            }\n        }).then(res => {\n            return res.json();\n        });\n    }\n\n    post(url = \"\", body) {\n        url = this.baseUrl + url;\n\n        return fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            },\n            body: body ? JSON.stringify(body) : null\n        }).then(res => {\n            return res.json();\n        });\n    }\n}","import { BaseBigNumber } from \"../abstracts\";\nimport { utils } from \"../utils\";\n\nexport class Converter {\n    static toHex(amount: BaseBigNumber | string | number) {\n        const dataType = typeof amount;\n        if (dataType === 'number') {\n            amount = new utils.BN(amount);\n        } else if (dataType === 'string') {\n            if ((amount as string).slice(0, 2) === '0x') {\n                return amount;\n            }\n            amount = new utils.BN(amount);\n        }\n        if (utils.BN.isBN(amount)) {\n            return '0x' + amount.toString(16);\n        }\n        else {\n            throw new Error(`Invalid value ${amount}, value is not a number.`);\n        }\n    }\n}","import { IBaseClientConfig } from \"../interfaces\";\nimport { BaseWeb3Client } from \"../abstracts\";\nimport { ABIManager } from \"../utils\";\nimport { Logger } from \"./logger\";\nimport { utils } from \"..\";\n\nexport class Web3SideChainClient<T_CONFIG> {\n    parent: BaseWeb3Client;\n    child: BaseWeb3Client;\n\n    config: T_CONFIG;\n\n    abiManager: ABIManager;\n\n    logger = new Logger();\n\n    init(config: IBaseClientConfig) {\n        config = config || {} as any;\n        config.parent.defaultConfig = config.parent.defaultConfig || {} as any;\n        config.child.defaultConfig = config.child.defaultConfig || {} as any;\n        this.config = config as any;\n\n        // tslint:disable-next-line\n        const Web3Client = utils.Web3Client;\n\n        if (!Web3Client) {\n            throw new Error(\"Web3Client is not set\");\n        }\n\n        this.parent = new (Web3Client as any)(config.parent.provider, this.logger);\n        this.child = new (Web3Client as any)(config.child.provider, this.logger);\n\n        this.logger.enableLog(config.log);\n\n        const network = config.network;\n        const version = config.version;\n        const abiManager = this.abiManager =\n            new ABIManager(network, version);\n        this.logger.log(\"init called\", abiManager);\n        return abiManager.init().catch(err => {\n            throw new Error(`network ${network} - ${version} is not supported`);\n        });\n    }\n\n    getABI(name: string, type?: string) {\n        return this.abiManager.getABI(name, type);\n    }\n\n    getConfig(path: string) {\n        return this.abiManager.getConfig(path);\n    }\n\n    get mainPlasmaContracts() {\n        return this.getConfig(\"Main.Contracts\");\n    }\n\n    get mainPOSContracts() {\n        return this.getConfig(\"Main.POSContracts\");\n    }\n\n    isEIP1559Supported(isParent: boolean): boolean {\n        return isParent ? this.getConfig(\"Main.SupportsEIP1559\") :\n            this.getConfig(\"Matic.SupportsEIP1559\");\n    }\n\n\n}\n\n","export const promiseResolve = <T>(value?) => {\n    return Promise.resolve<T>(value);\n};","import { Web3SideChainClient } from \"./web3_side_chain_client\";\nimport { ITransactionRequestConfig, ITransactionOption, IContractInitParam, IPOSClientConfig, IBaseClientConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { BaseContractMethod, BaseContract, BaseWeb3Client } from \"../abstracts\";\nimport { Converter, merge } from \"../utils\";\nimport { promiseResolve } from \"./promise_resolve\";\nimport { ERROR_TYPE } from \"../enums\";\nimport { POSERC1155TransferParam, TYPE_AMOUNT } from \"../types\";\nimport { ErrorHelper } from \"./error_helper\";\n\nexport interface ITransactionConfigParam {\n    txConfig: ITransactionRequestConfig;\n    method?: BaseContractMethod;\n    isWrite?: boolean;\n    isParent?: boolean;\n}\n\nexport class BaseToken<T_CLIENT_CONFIG> {\n\n    private contract_: BaseContract;\n\n    constructor(\n        protected contractParam: IContractInitParam,\n        protected client: Web3SideChainClient<T_CLIENT_CONFIG>,\n    ) {\n    }\n\n\n    getContract(): Promise<BaseContract> {\n        if (this.contract_) {\n            return promiseResolve<BaseContract>(this.contract_ as any);\n        }\n        const contractParam = this.contractParam;\n        return this.client.getABI(\n            contractParam.name,\n            contractParam.bridgeType,\n        ).then(abi => {\n            this.contract_ = this.getContract_({\n                abi,\n                isParent: contractParam.isParent,\n                tokenAddress: contractParam.address\n            });\n            return this.contract_;\n        });\n    }\n\n    protected processWrite(method: BaseContractMethod, option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        this.client.logger.log(\"process write\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: method.address\n                    } as ITransactionRequestConfig);\n                }\n                const methodResult = method.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected sendTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process write\");\n\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                const methodResult = client.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected readTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"write tx config created\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                return client.read(\n                    config,\n                );\n            });\n    }\n\n    private validateTxOption_(option: ITransactionOption) {\n        if (typeof option !== 'object' || Array.isArray(option)) {\n            new ErrorHelper(ERROR_TYPE.TransactionOptionNotObject).throw();\n        }\n    }\n\n    protected processRead<T>(method: BaseContractMethod, option: ITransactionOption = {}): Promise<T> {\n        this.validateTxOption_(option);\n        this.client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: false,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"read tx config created\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: this.contract_.address\n                    } as ITransactionRequestConfig);\n                }\n                return method.read(\n                    config,\n                );\n            });\n    }\n\n    protected getClient(isParent) {\n        return isParent ? this.client.parent :\n            this.client.child;\n    }\n\n    private getContract_({ isParent, tokenAddress, abi }) {\n        const client = this.getClient(isParent);\n        return client.getContract(tokenAddress, abi);\n    }\n\n    protected get parentDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.parent.defaultConfig;\n    }\n\n    protected get childDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.child.defaultConfig;\n    }\n\n    protected createTransactionConfig({ txConfig, method, isParent, isWrite }: ITransactionConfigParam) {\n        const defaultConfig = isParent ? this.parentDefaultConfig : this.childDefaultConfig;\n        txConfig = merge(defaultConfig, (txConfig || {}));\n        const client = isParent ? this.client.parent :\n            this.client.child;\n        client.logger.log(\"txConfig\", txConfig, \"onRoot\", isParent, \"isWrite\", isWrite);\n        const estimateGas = (config: ITransactionRequestConfig) => {\n            return method ? method.estimateGas(config) :\n                client.estimateGas(config);\n        };\n        // txConfig.chainId = Converter.toHex(txConfig.chainId) as any;\n        if (isWrite) {\n            const { maxFeePerGas, maxPriorityFeePerGas } = txConfig;\n            const isEIP1559Supported = this.client.isEIP1559Supported(isParent);\n            const isMaxFeeProvided = (maxFeePerGas || maxPriorityFeePerGas);\n\n            if (!isEIP1559Supported && isMaxFeeProvided) {\n                client.logger.error(ERROR_TYPE.EIP1559NotSupported, isParent).throw();\n            }\n            // const [gasLimit, nonce, chainId] = \n            return Promise.all([\n                !(txConfig.gasLimit)\n                    ? estimateGas({\n                        from: txConfig.from, value: txConfig.value\n                    })\n                    : txConfig.gasLimit,\n                !txConfig.nonce ?\n                    client.getTransactionCount(txConfig.from, 'pending')\n                    : txConfig.nonce,\n                !txConfig.chainId ?\n                    client.getChainId() : txConfig.chainId\n            ]).then(result => {\n                const [gasLimit, nonce, chainId] = result;\n                client.logger.log(\"options filled\");\n\n                txConfig.gasLimit = Number(gasLimit);\n                txConfig.nonce = nonce;\n                txConfig.chainId = chainId;\n                return txConfig;\n            });\n        }\n        return promiseResolve<ITransactionRequestConfig>(txConfig);\n    }\n\n    protected transferERC20(to: string, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transfer\",\n                to,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected transferERC721(from: string, to: string, tokenId: string, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transferFrom\",\n                from,\n                to,\n                tokenId\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected checkForRoot(methodName) {\n        if (!this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnRoot, methodName).throw();\n        }\n    }\n\n    protected checkForChild(methodName) {\n        if (this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnChild, methodName).throw();\n        }\n    }\n\n    protected transferERC1155(param: POSERC1155TransferParam, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"safeTransferFrom\",\n                param.from,\n                param.to,\n                Converter.toHex(param.tokenId),\n                Converter.toHex(param.amount),\n                param.data || '0x'\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n}","import { service, NetworkService } from \"../services\";\n\nexport const setProofApi = (url: string) => {\n    const urlLength = url.length;\n    if (url[urlLength - 1] !== '/') {\n        url += '/';\n    }\n    url += 'api/v1/';\n    service.network = new NetworkService(url);\n};","export function resolve(obj, path) {\n    const properties = Array.isArray(path) ? path : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], obj);\n}","import { Web3SideChainClient } from \"../utils\";\nimport { ExitUtil } from \"../pos\";\nimport { BaseToken, utils } from \"..\";\n\nexport class BridgeClient<T> {\n\n    client: Web3SideChainClient<T> = new Web3SideChainClient();\n\n    exitUtil: ExitUtil;\n\n    /**\n     * check whether a txHash is checkPointed \n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof BridgeClient\n     */\n    isCheckPointed(txHash: string) {\n        return this.exitUtil.isCheckPointed(\n            txHash\n        );\n    }\n\n    isDeposited(depositTxHash: string) {\n        const client = this.client;\n\n        const token = new BaseToken({\n            address: client.abiManager.getConfig(\"Matic.GenesisContracts.StateReceiver\"),\n            isParent: false,\n            name: 'StateReceiver',\n            bridgeType: 'genesis'\n        }, client);\n\n        return token.getContract().then(contract => {\n            return Promise.all([\n                client.parent.getTransactionReceipt(depositTxHash),\n                token['processRead']<string>(\n                    contract.method(\"lastStateId\")\n                )\n            ]);\n        }).then(result => {\n            const [receipt, lastStateId] = result;\n            const eventSignature = `0x103fed9db65eac19c4d870f49ab7520fe03b99f1838e5996caf47e9e43308392`;\n            const targetLog = receipt.logs.find(q => q.topics[0] === eventSignature);\n            if (!targetLog) {\n                throw new Error(\"StateSynced event not found\");\n            }\n            const rootStateId = client.child.decodeParameters(targetLog.topics[1], ['uint256'])[0];\n            const rootStateIdBN = utils.BN.isBN(rootStateId) ? rootStateId : new utils.BN(rootStateId);\n            return new utils.BN(lastStateId).gte(\n                rootStateIdBN\n            );\n        });\n    }\n\n}","import { service } from \"../services\";\nimport { resolve, promiseResolve } from \".\";\n\ntype T_ABI_CACHE = {\n    [networkName: string]: {\n        [version: string]: {\n            address: any,\n            abi: {\n                [bridgeType: string]: {\n                    [contractName: string]: any\n                }\n            }\n        }\n    }\n};\n\nconst cache: T_ABI_CACHE = {};\n\nexport class ABIManager {\n    constructor(public networkName: string, public version: string) {\n\n    }\n\n    init() {\n        return service.abi.getAddress(\n            this.networkName, this.version\n        ).then(result => {\n            cache[this.networkName] = {\n                [this.version]: {\n                    address: result,\n                    abi: {}\n                }\n            };\n        });\n    }\n\n    getConfig(path: string) {\n        return resolve(\n            cache[this.networkName][this.version].address,\n            path\n        );\n    }\n\n    getABI(contractName: string, bridgeType = 'plasma'): Promise<any> {\n        const targetBridgeABICache = cache[this.networkName][this.version].\n            abi[bridgeType];\n\n        if (targetBridgeABICache) {\n            const abiForContract = targetBridgeABICache[contractName];\n            if (abiForContract) {\n                return promiseResolve<any>(abiForContract);\n            }\n        }\n        return service.abi.getABI(\n            this.networkName,\n            this.version,\n            bridgeType,\n            contractName\n        ).then(result => {\n            this.setABI(contractName, bridgeType, result);\n            return result;\n        });\n    }\n\n    setABI(contractName: string, bridgeType: string, abi: any) {\n        const abiStore = cache[this.networkName][this.version].abi;\n        if (!abiStore[bridgeType]) {\n            abiStore[bridgeType] = {};\n        }\n        abiStore[bridgeType][contractName] = abi;\n    }\n}","export const throwNotImplemented = <T>() => {\n    throw new Error(\"not implemented\");\n    return '' as any as T;\n};","import { BaseWeb3Client, Converter, TYPE_AMOUNT } from \"..\";\nimport { EmptyBigNumber } from \"../implementation\";\n\nexport * from \"./use\";\nexport * from \"./event_bus\";\nexport * from \"./logger\";\nexport * from \"./merge\";\nexport * from \"./map_promise\";\nexport * from \"./proof_util\";\nexport * from \"./http_request\";\nexport * from \"./converter\";\nexport * from \"./web3_side_chain_client\";\nexport * from \"./base_token\";\nexport * from \"./set_proof_api_url\";\nexport * from \"./resolve\";\nexport * from \"./promise_resolve\";\nexport * from \"./bridge_client\";\nexport * from \"./abi_manager\";\nexport * from \"./not_implemented\";\n\n\nexport const utils = {\n    converter: Converter,\n    Web3Client: BaseWeb3Client,\n    BN: EmptyBigNumber\n};","import { defaultExport } from \"./default\";\n\nexport * from \"./utils\";\nexport * from \"./enums\";\nexport * from \"./pos\";\nexport * from \"./interfaces\";\nexport * from \"./types\";\nexport * from \"./constant\";\nexport * from \"./abstracts\";\nexport * from \"./services\";\n\nexport default defaultExport;\n\n","module.exports = require(\"ethereumjs-util\");","export enum Log_Event_Signature {\n    // PlasmaErc20WithdrawEventSig = '0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f',\n    // PlasmaErc721WithdrawEventSig = '0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb',\n    Erc20Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc721Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc1155Transfer = '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62',\n    Erc721BatchTransfer = '0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df',\n    Erc1155BatchTransfer = '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb',\n    Erc721TransferWithMetadata = '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14',\n\n}","export enum ERROR_TYPE {\n    AllowedOnRoot = \"allowed_on_root\",\n    AllowedOnChild = \"allowed_on_child\",\n    Unknown = \"unknown\",\n    ProofAPINotSet = \"proof_api_not_set\",\n    TransactionOptionNotObject = \"transation_object_not_object\",\n    BurnTxNotCheckPointed = \"burn_tx_not_checkpointed\",\n    EIP1559NotSupported = \"eip-1559_not_supported\",\n    NullSpenderAddress = \"null_spender_address\"\n}","import { HttpRequest } from \"../utils\";\n\nexport class ABIService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    getABI(network: string, version: string, bridgeType: string, contractName: string) {\n        const url = `${network}/${version}/artifacts/${bridgeType}/${contractName}.json`;\n        return this.httpRequest.get(url).then((result: any) => {\n            return result.abi;\n        });\n    }\n\n    getAddress(network: string, version: string) {\n        const url = `${network}/${version}/index.json`;\n        return this.httpRequest.get(url);\n    }\n}","import { BaseBigNumber, utils } from \"..\";\nimport { HttpRequest } from \"../utils\";\n\nexport class NetworkService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    private createUrl(network: string, url: string) {\n        return `${network === 'mainnet' ? 'matic' : 'mumbai'}${url}`;\n    }\n\n    getBlockIncluded(network: string, blockNumber: number) {\n\n        const url = this.createUrl(network, `/block-included/${blockNumber}`);\n        return this.httpRequest.get<{\n            start: string;\n            end: string;\n            headerBlockNumber: BaseBigNumber;\n        }>(url).then(result => {\n            const headerBlockNumber = result.headerBlockNumber as any as string;\n            const decimalHeaderBlockNumber = headerBlockNumber.slice(0, 2) === '0x' ? parseInt(\n                headerBlockNumber, 16\n            ) : headerBlockNumber;\n            result.headerBlockNumber = new utils.BN(decimalHeaderBlockNumber);\n            return result;\n        });\n    }\n\n    getProof(network: string, start, end, blockNumber) {\n        const url = this.createUrl(network, `/fast-merkle-proof?start=${start}&end=${end}&number=${blockNumber}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.proof;\n        });\n    }\n}\n","import { ABIService } from \"./abi_service\";\nimport { config } from \"../config\";\nimport { NetworkService } from \"./network_service\";\n\nexport * from \"./network_service\";\n\nclass Service {\n    network: NetworkService;\n    abi: ABIService;\n}\n\nexport const service = new Service();\nservice.abi = new ABIService(config.abiStoreUrl);\n\n\n\n","\nexport const config = {\n    abiStoreUrl: 'https://static.matic.network/network/'\n};","import { ERROR_TYPE } from \"../enums\";\nimport { IError } from \"../interfaces\";\n\nexport class ErrorHelper implements IError {\n    type: ERROR_TYPE;\n    message: string;\n\n    constructor(type: ERROR_TYPE, info?) {\n        this.type = type;\n        this.message = this.getMsg_(info);\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_(info) {\n        let errMsg: string;\n        switch (this.type) {\n            case ERROR_TYPE.AllowedOnChild:\n                errMsg = `The action ${info} is allowed only on child token.`;\n                break;\n            case ERROR_TYPE.AllowedOnRoot:\n                errMsg = `The action ${info} is allowed only on root token.`;\n                break;\n            case ERROR_TYPE.ProofAPINotSet:\n                errMsg = `Proof api is not set, please set it using \"setProofApi\"`;\n                break;\n            case ERROR_TYPE.BurnTxNotCheckPointed:\n                errMsg = `Burn transaction has not been checkpointed as yet`;\n                break;\n            case ERROR_TYPE.EIP1559NotSupported:\n                errMsg = `${info ? 'Root' : 'Child'} chain doesn't support eip-1559`;\n                break;\n            case ERROR_TYPE.NullSpenderAddress:\n                errMsg = `Please provide spender address.`;\n                break;\n            default:\n                if (!this.type) {\n                    this.type = ERROR_TYPE.Unknown;\n                }\n                errMsg = this.message;\n                break;\n        }\n        return errMsg;\n    }\n}","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","import { BaseToken, Web3SideChainClient, promiseResolve } from \"../utils\";\nimport { IContractInitParam, IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { IPOSContracts } from \"../interfaces\";\n\nexport class POSToken extends BaseToken<IPOSClientConfig> {\n\n    private predicateAddress: string;\n\n    constructor(\n        contractParam: IContractInitParam,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        protected getPOSContracts: () => IPOSContracts\n    ) {\n        super(contractParam, client);\n    }\n\n    protected get rootChainManager() {\n        return this.getPOSContracts().rootChainManager;\n    }\n\n    protected get exitUtil() {\n        return this.getPOSContracts().exitUtil;\n    }\n\n\n    getPredicateAddress(): Promise<string> {\n        if (this.predicateAddress) {\n            return promiseResolve(this.predicateAddress);\n        }\n        return this.rootChainManager.method(\n            \"tokenToType\",\n            this.contractParam.address\n        ).then(method => {\n            return method.read();\n        }).then(tokenType => {\n            if (!tokenType) {\n                throw new Error('Invalid Token Type');\n            }\n            return this.rootChainManager.method(\n                \"typeToPredicate\", tokenType\n            );\n        }).then(typeToPredicateMethod => {\n            return typeToPredicateMethod.read<string>();\n        }).then(predicateAddress => {\n            this.predicateAddress = predicateAddress;\n            return predicateAddress;\n        });\n    }\n\n    protected isWithdrawn(txHash: string, eventSignature: string) {\n        if (!txHash) {\n            throw new Error(`txHash not provided`);\n        }\n        return this.exitUtil.getExitHash(\n            txHash, eventSignature\n        ).then(exitHash => {\n            return this.rootChainManager.isExitProcessed(\n                exitHash\n            );\n        });\n    }\n\n    protected withdrawExitPOS(burnTxHash: string, eventSignature: string, isFast: boolean, option: ITransactionOption) {\n        return this.exitUtil.buildPayloadForExit(\n            burnTxHash,\n            eventSignature,\n            isFast\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n}","import { ITransactionOption } from \"../interfaces\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERROR_TYPE, Log_Event_Signature } from \"../enums\";\nimport { IAllowanceTransactionOption, IApproveTransactionOption, IPOSClientConfig, MAX_AMOUNT, promiseResolve } from \"..\";\nimport { IPOSContracts } from \"../interfaces/pos_contracts\";\n\nexport class ERC20 extends POSToken {\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC20',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    getBalance(userAddress: string, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * get allowance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getAllowance(userAddress: string, option: IAllowanceTransactionOption = {}) {\n        const spenderAddress = option.spenderAddress;\n\n        const predicatePromise = spenderAddress ? promiseResolve(spenderAddress) : this.getPredicateAddress();\n\n        return Promise.all([predicatePromise, this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"allowance\",\n                userAddress,\n                predicateAddress,\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    approve(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        const spenderAddress = option.spenderAddress;\n\n        if (!spenderAddress && !this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.NullSpenderAddress).throw();\n        }\n\n        const predicatePromise = spenderAddress ? promiseResolve(spenderAddress) : this.getPredicateAddress();\n\n        return Promise.all([predicatePromise, this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveMax(option?: ITransactionOption) {\n        return this.approve(\n            MAX_AMOUNT\n            , option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    deposit(amount: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    private depositEther_(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption = {}) {\n        this.checkForRoot(\"depositEther\");\n\n\n        option.value = Converter.toHex(amount);\n        return this.rootChainManager.method(\"depositEtherFor\", userAddress).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * initiate withdraw by burning provided amount\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawStart(amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc20Transfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     *  Note:- It create the proof in api call for fast exit.\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc20Transfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @returns\n     * @memberof ERC20\n     */\n    isWithdrawExited(burnTxHash: string) {\n        return this.isWithdrawn(burnTxHash, Log_Event_Signature.Erc20Transfer);\n    }\n\n    /**\n     * transfer amount to another user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    transfer(amount: TYPE_AMOUNT, to: string, option?: ITransactionOption) {\n        return this.transferERC20(to, amount, option);\n    }\n\n}","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class RootChainManager extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChainManager',\n            bridgeType: 'pos',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    deposit(userAddress: string, tokenAddress: string, depositData: string, option?: ITransactionOption) {\n        return this.method(\n            \"depositFor\",\n            userAddress,\n            tokenAddress,\n            depositData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    exit(exitPayload: string, option: ITransactionOption) {\n        return this.method(\"exit\", exitPayload).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    isExitProcessed(exitHash: string) {\n        return this.method(\n            \"processedExits\", exitHash\n        ).then(method => {\n            return this.processRead<boolean>(method);\n        });\n    }\n\n}","import { RootChain } from \"./root_chain\";\nimport { Converter, ProofUtil, Web3SideChainClient } from \"../utils\";\nimport ethUtils from \"ethereumjs-util\";\nimport { IBlockWithTransaction, ITransactionReceipt } from \"../interfaces\";\nimport { service } from \"../services\";\nimport { BaseBigNumber, BaseWeb3Client } from \"../abstracts\";\nimport { ErrorHelper } from \"../utils/error_helper\";\nimport { ERROR_TYPE, IBaseClientConfig, IRootBlockInfo, utils } from \"..\";\n\ninterface IChainBlockInfo {\n    lastChildBlock: string;\n    txBlockNumber: number;\n}\n\n\n\nexport class ExitUtil {\n    private maticClient_: BaseWeb3Client;\n\n    rootChain: RootChain;\n\n    requestConcurrency: number;\n    config: IBaseClientConfig;\n\n    constructor(client: Web3SideChainClient<IBaseClientConfig>, rootChain: RootChain) {\n        this.maticClient_ = client.child;\n        this.rootChain = rootChain;\n        const config = client.config;\n        this.config = config;\n        this.requestConcurrency = config.requestConcurrency;\n    }\n\n    private getLogIndex_(logEventSig: string, receipt: ITransactionReceipt) {\n        let logIndex = -1;\n\n        switch (logEventSig) {\n            case '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef':\n            case '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            case '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62':\n            case '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[3].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            default:\n                logIndex = receipt.logs.findIndex(log => log.topics[0].toLowerCase() === logEventSig.toLowerCase());\n        }\n        if (logIndex < 0) {\n            throw new Error(\"Log not found in receipt\");\n        }\n        return logIndex;\n    }\n\n    getChainBlockInfo(burnTxHash: string) {\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransaction(burnTxHash),\n        ]).then(result => {\n            return {\n                lastChildBlock: result[0],\n                txBlockNumber: result[1].blockNumber\n            } as IChainBlockInfo;\n        });\n    }\n\n    private isCheckPointed_(data: IChainBlockInfo) {\n        // lastchild block is greater equal to transacton block number; \n        return new utils.BN(data.lastChildBlock).gte(\n            new utils.BN(data.txBlockNumber)\n        );\n    }\n\n    isCheckPointed(burnTxHash: string) {\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(result => {\n            return this.isCheckPointed_(\n                result\n            );\n        });\n    }\n\n    private getRootBlockInfo(txBlockNumber: number) {\n        // find in which block child was included in parent\n        let rootBlockNumber: BaseBigNumber;\n        return this.rootChain.findRootBlockFromChild(\n            txBlockNumber\n        ).then(blockNumber => {\n            rootBlockNumber = blockNumber;\n            return this.rootChain.method(\n                \"headerBlocks\",\n                Converter.toHex(blockNumber)\n            );\n        }).then(method => {\n            return method.read<IRootBlockInfo>();\n        }).then(rootBlockInfo => {\n            return {\n                headerBlockNumber: rootBlockNumber,\n                end: rootBlockInfo.end.toString(),\n                start: rootBlockInfo.start.toString(),\n            } as IRootBlockInfo;\n        });\n\n    }\n\n    private getRootBlockInfoFromAPI(txBlockNumber: number) {\n        this.maticClient_.logger.log(\"block info from API 1\");\n        return service.network.getBlockIncluded(\n            this.config.network,\n            txBlockNumber\n        ).then(headerBlock => {\n            this.maticClient_.logger.log(\"block info from API 2\", headerBlock);\n            if (!headerBlock || !headerBlock.start || !headerBlock.end || !headerBlock.headerBlockNumber) {\n                throw Error('Network API Error');\n            }\n            return headerBlock;\n        }).catch(err => {\n            this.maticClient_.logger.log(\"block info from API\", err);\n            return this.getRootBlockInfo(txBlockNumber);\n        });\n    }\n\n    private getBlockProof(txBlockNumber: number, rootBlockInfo: { start, end }) {\n        return ProofUtil.buildBlockProof(\n            this.maticClient_,\n            parseInt(rootBlockInfo.start, 10),\n            parseInt(rootBlockInfo.end, 10),\n            parseInt(txBlockNumber + '', 10)\n        );\n    }\n\n    private getBlockProofFromAPI(txBlockNumber: number, rootBlockInfo: { start, end }) {\n\n        return service.network.getProof(\n            this.config.network,\n            rootBlockInfo.start,\n            rootBlockInfo.end,\n            txBlockNumber\n        ).then(blockProof => {\n            if (!blockProof) {\n                throw Error('Network API Error');\n            }\n            this.maticClient_.logger.log(\"block proof from API 1\");\n            return blockProof;\n        }).catch(_ => {\n            return this.getBlockProof(txBlockNumber, rootBlockInfo);\n        });\n    }\n\n    buildPayloadForExit(burnTxHash: string, logEventSig: string, isFast: boolean) {\n\n        if (isFast && !service.network) {\n            new ErrorHelper(ERROR_TYPE.ProofAPINotSet).throw();\n        }\n\n        let txBlockNumber: number,\n            rootBlockInfo: IRootBlockInfo,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction,\n            blockProof;\n\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(blockInfo => {\n            if (!this.isCheckPointed_(blockInfo)) {\n                throw new Error(\n                    'Burn transaction has not been checkpointed as yet'\n                );\n            }\n\n            txBlockNumber = blockInfo.txBlockNumber;\n            return Promise.all([\n                this.maticClient_.getTransactionReceipt(burnTxHash),\n                this.maticClient_.getBlockWithTransaction(txBlockNumber)\n            ]);\n        }).then(result => {\n            [receipt, block] = result;\n            return (\n                isFast ? this.getRootBlockInfoFromAPI(txBlockNumber) :\n                    this.getRootBlockInfo(txBlockNumber)\n            );\n        }).then(rootBlockInfoResult => {\n            rootBlockInfo = rootBlockInfoResult;\n            // build block proof\n            return (\n                isFast ? this.getBlockProofFromAPI(txBlockNumber, rootBlockInfo) :\n                    this.getBlockProof(txBlockNumber, rootBlockInfo)\n            );\n        }).then(blockProofResult => {\n            blockProof = blockProofResult;\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            const logIndex = this.getLogIndex_(\n                logEventSig, receipt\n            );\n\n            return this.encodePayload_(\n                rootBlockInfo.headerBlockNumber.toNumber(),\n                blockProof,\n                txBlockNumber,\n                block.timestamp,\n                Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                receiptProof.parentNodes,\n                receiptProof.path,\n                logIndex\n            );\n        });\n    }\n\n    private encodePayload_(\n        headerNumber,\n        buildBlockProof,\n        blockNumber,\n        timestamp,\n        transactionsRoot,\n        receiptsRoot,\n        receipt,\n        receiptParentNodes,\n        path,\n        logIndex\n    ) {\n        return ethUtils.bufferToHex(\n            ethUtils.rlp.encode([\n                headerNumber,\n                buildBlockProof,\n                blockNumber,\n                timestamp,\n                ethUtils.bufferToHex(transactionsRoot),\n                ethUtils.bufferToHex(receiptsRoot),\n                ethUtils.bufferToHex(receipt),\n                ethUtils.bufferToHex(ethUtils.rlp.encode(receiptParentNodes)),\n                ethUtils.bufferToHex(Buffer.concat([Buffer.from('00', 'hex'), path])),\n                logIndex,\n            ])\n        );\n    }\n\n    getExitHash(burnTxHash, logEventSig) {\n        let lastChildBlock: string,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction;\n\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransactionReceipt(burnTxHash)\n        ]).then(result => {\n            lastChildBlock = result[0];\n            receipt = result[1];\n            return this.maticClient_.getBlockWithTransaction(\n                receipt.blockNumber\n            );\n        }).then(blockResult => {\n            block = blockResult;\n            if (!this.isCheckPointed_({ lastChildBlock: lastChildBlock, txBlockNumber: receipt.blockNumber })) {\n                this.maticClient_.logger.error(ERROR_TYPE.BurnTxNotCheckPointed).throw();\n            }\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            const logIndex = this.getLogIndex_(logEventSig, receipt);\n            const nibbleArr = [];\n            receiptProof.path.forEach(byte => {\n                nibbleArr.push(Buffer.from('0' + (byte / 0x10).toString(16), 'hex'));\n                nibbleArr.push(Buffer.from('0' + (byte % 0x10).toString(16), 'hex'));\n            });\n\n            return this.maticClient_.etheriumSha3(\n                receipt.blockNumber, ethUtils.bufferToHex(Buffer.concat(nibbleArr)), logIndex\n            );\n        });\n    }\n}","import { BaseToken, utils, Web3SideChainClient } from \"../utils\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { BaseBigNumber } from \"..\";\n\nexport class RootChain extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChain',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    getLastChildBlock() {\n        return this.method(\"getLastChildBlock\").then(method => {\n            return method.read<string>();\n        });\n    }\n\n    async findRootBlockFromChild(childBlockNumber: TYPE_AMOUNT): Promise<BaseBigNumber> {\n        const bigOne = new utils.BN(1);\n        const bigtwo = new utils.BN(2);\n        const checkPointInterval = new utils.BN(10000);\n\n        childBlockNumber = new utils.BN(childBlockNumber);\n        // first checkpoint id = start * 10000\n        let start = bigOne;\n\n        // last checkpoint id = end * 10000\n        const method = await this.method(\"currentHeaderBlock\");\n        const currentHeaderBlock = await method.read<string>();\n        let end = new utils.BN(currentHeaderBlock).div(\n            checkPointInterval\n        );\n\n        // binary search on all the checkpoints to find the checkpoint that contains the childBlockNumber\n        let ans;\n        while (start.lte(end)) {\n            if (start.eq(end)) {\n                ans = start;\n                break;\n            }\n            const mid = start.add(end).div(bigtwo);\n            const headerBlocksMethod = await this.method(\n                \"headerBlocks\",\n                mid.mul(checkPointInterval).toString()\n            );\n            const headerBlock = await headerBlocksMethod.read<{ start: number, end: number }>();\n\n            const headerStart = new utils.BN(headerBlock.start);\n            const headerEnd = new utils.BN(headerBlock.end);\n\n            if (headerStart.lte(childBlockNumber) && childBlockNumber.lte(headerEnd)) {\n                // if childBlockNumber is between the upper and lower bounds of the headerBlock, we found our answer\n                ans = mid;\n                break;\n            } else if (headerStart.gt(childBlockNumber)) {\n                // childBlockNumber was checkpointed before this header\n                end = mid.sub(bigOne);\n            } else if (headerEnd.lt(childBlockNumber)) {\n                // childBlockNumber was checkpointed after this header\n                start = mid.add(bigOne);\n            }\n        }\n        return ans.mul(checkPointInterval);\n    }\n\n}","import { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ExitUtil } from \"./exit_util\";\nimport { Log_Event_Signature } from \"../enums\";\n\nexport class ERC721 extends POSToken {\n\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC721',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    private validateMany_(tokenIds) {\n        if (tokenIds.length > 20) {\n            throw new Error('can not process more than 20 tokens');\n        }\n        return tokenIds.map(tokenId => {\n            return Converter.toHex(tokenId);\n        });\n    }\n\n    /**\n     * get tokens count for the user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokensCount(userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, options);\n        }).then(count => {\n            return Number(count);\n        });\n    }\n\n    /**\n     * returns token id on supplied index for user\n     *\n     * @param {number} index\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokenIdAtIndexForUser(index: number, userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"tokenOfOwnerByIndex\",\n                userAddress,\n                index\n            );\n\n            return this.processRead<string>(method, options);\n        });\n    }\n\n    /**\n     * get all tokens for user\n     *\n     * @param {string} userAddress\n     * @param {*} [limit=Infinity]\n     * @returns\n     * @memberof ERC721\n     */\n    getAllTokens(userAddress: string, limit = Infinity) {\n        return this.getTokensCount(userAddress).then(count => {\n            count = Number(count);\n            if (count > limit) {\n                count = limit;\n            }\n            const promises = [];\n            for (let i = 0; i < count; i++) {\n                promises.push(\n                    this.getTokenIdAtIndexForUser(i, userAddress)\n                );\n            }\n            return Promise.all(\n                promises\n            );\n        });\n    }\n\n    isApproved(tokenId: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApproved\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"getApproved\",\n                tokenId\n            );\n            return Promise.all([\n                this.processRead<string>(method, option),\n                this.getPredicateAddress()\n            ]).then(result => {\n                return result[0] === result[1];\n            });\n        });\n    }\n\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    approve(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approveAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n\n    deposit(tokenId: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(tokenId)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    depositMany(tokenIds: TYPE_AMOUNT[], userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [tokensInHex],\n            ['uint256[]'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    withdrawStart(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartWithMetaData(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartWithMetaData\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawWithMetadata\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitWithMetaData(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitWithMetaData\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721TransferWithMetadata,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitMany\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721BatchTransfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721BatchTransfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitFasterWithMetaData(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterWithMetaData\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721TransferWithMetadata,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721Transfer\n        );\n    }\n\n    isWithdrawWithMetaDataExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721TransferWithMetadata\n        );\n    }\n\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721BatchTransfer\n        );\n    }\n\n    /**\n     * tranfer to another user\n     *\n     * @param {string} tokenId\n     * @param {string} from\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC721\n     */\n    transfer(tokenId: string, from: string, to: string, option?: ITransactionOption) {\n        return this.transferERC721(\n            from,\n            to,\n            tokenId,\n            option\n        );\n    }\n\n}","import { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { Converter, promiseResolve, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { Log_Event_Signature } from \"../enums\";\nimport { IPOSContracts, IPOSERC1155Address } from \"../interfaces\";\nimport { POSERC1155DepositBatchParam, POSERC1155DepositParam, POSERC1155TransferParam, TYPE_AMOUNT } from \"..\";\n\nexport class ERC1155 extends POSToken {\n\n    mintablePredicateAddress: string;\n\n    get addressConfig(): IPOSERC1155Address {\n        return this.client.config.erc1155 || {};\n    }\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC1155',\n            bridgeType: 'pos'\n        }, client, getContracts);\n\n    }\n\n    private getAddress_(value: string) {\n        const addresses = this.addressConfig;\n        if (addresses[value]) {\n            return promiseResolve(addresses[value]);\n        }\n\n        return this.client.getConfig(value);\n    }\n\n    /**\n     * get balance of a user for supplied token\n     *\n     * @param {string} userAddress\n     * @param {TYPE_AMOUNT} tokenId\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    getBalance(userAddress: string, tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * check if a user is approved for all tokens\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    private approveAll_(predicateAddressPromise: Promise<string>, option: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), predicateAddressPromise]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * approve all tokens \n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return this.approveAll_(\n            this.getPredicateAddress(), option\n        );\n    }\n\n    /**\n     * approve all tokens for mintable token\n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAllForMintable(option?: ITransactionOption) {\n        this.checkForRoot(\"approveForMintable\");\n        const addressPath = \"Main.POSContracts.MintableERC1155PredicateProxy\";\n        return this.approveAll_(\n            this.getAddress_(addressPath), option\n        );\n    }\n\n    /**\n     * deposit supplied amount of token for a user \n     *\n     * @param {POSERC1155DepositParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    deposit(param: POSERC1155DepositParam, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n        return this.depositMany({\n            amounts: [param.amount],\n            tokenIds: [param.tokenId],\n            userAddress: param.userAddress,\n            data: param.data\n        }, option);\n    }\n\n    /**\n     * deposit supplied amount of multiple token for user\n     *\n     * @param {POSERC1155DepositBatchParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    depositMany(param: POSERC1155DepositBatchParam, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const { tokenIds, amounts, data, userAddress } = param;\n        const emptyHex = Converter.toHex(0);\n        const amountInABI = this.client.parent.encodeParameters(\n            [\n                tokenIds.map(t => Converter.toHex(t)),\n                amounts.map(a => Converter.toHex(a)),\n                data || emptyHex\n            ],\n            ['uint256[]', 'uint256[]', 'bytes'],\n        );\n\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n\n    }\n\n    /**\n     * start withdraw process by burning the required amount for a token\n     *\n     * @param {string} tokenId\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStart(tokenId: TYPE_AMOUNT, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawSingle\",\n                Converter.toHex(tokenId),\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * start the withdraw process by burning the supplied amount of multiple token at a time\n     *\n     * @param {TYPE_AMOUNT[]} tokenIds\n     * @param {TYPE_AMOUNT[]} amounts\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], amounts: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = tokenIds.map(t => {\n            return Converter.toHex(t);\n        });\n        const amountsInHex = amounts.map(t => {\n            return Converter.toHex(t);\n        });\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex,\n                amountsInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     * \n     * the process is faster because it uses proof api\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * the process is faster because it uses proof api\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155Transfer\n        );\n    }\n\n    /**\n     * check if batch exit has been completed for a transaction hash\n     *\n     * @param {string} txHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155BatchTransfer\n        );\n    }\n\n    /**\n     * transfer the required amount of a token to anothe user\n     *\n     * @param {POSERC1155TransferParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    transfer(param: POSERC1155TransferParam, option?: ITransactionOption) {\n        return this.transferERC1155(\n            param, option\n        );\n    }\n}","import { ERC20 } from \"./erc20\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { BridgeClient } from \"../utils\";\nimport { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { ExitUtil } from \"./exit_util\";\nimport { RootChain } from \"./root_chain\";\nimport { ERC721 } from \"./erc721\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERC1155 } from \"./erc1155\";\n\nexport * from \"./exit_util\";\nexport * from \"./root_chain_manager\";\nexport * from \"./root_chain\";\n\nexport class POSClient extends BridgeClient<IPOSClientConfig> {\n\n    rootChainManager: RootChainManager;\n\n    init(config: IPOSClientConfig) {\n        const client = this.client;\n\n        return client.init(config).then(_ => {\n            const mainPOSContracts = client.mainPOSContracts;\n            client.config = config = Object.assign(\n                {\n\n                    rootChainManager: mainPOSContracts.RootChainManagerProxy,\n                    rootChain: client.mainPlasmaContracts.RootChainProxy\n                } as IPOSClientConfig,\n                config\n            );\n\n            this.rootChainManager = new RootChainManager(\n                this.client,\n                config.rootChainManager,\n            );\n\n            const rootChain = new RootChain(\n                this.client,\n                config.rootChain,\n            );\n\n            this.exitUtil = new ExitUtil(\n                this.client,\n                rootChain\n            );\n\n            return this;\n        });\n    }\n\n    erc20(tokenAddress, isParent?: boolean) {\n        return new ERC20(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc721(tokenAddress, isParent?: boolean) {\n        return new ERC721(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc1155(tokenAddress, isParent?: boolean) {\n        return new ERC1155(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    depositEther(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption) {\n        return new ERC20(\n            '', true, this.client,\n            this.getContracts_.bind(this),\n        )['depositEther_'](amount, userAddress, option);\n    }\n\n    private getContracts_() {\n        return {\n            exitUtil: this.exitUtil,\n            rootChainManager: this.rootChainManager\n        } as IPOSContracts;\n    }\n}","import { ITransactionRequestConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContractMethod {\n    constructor(public logger: Logger) {\n\n    }\n    abstract get address(): string;\n    abstract read<T>(tx?: ITransactionRequestConfig,): Promise<T>;\n    abstract write(tx: ITransactionRequestConfig,): ITransactionWriteResult;\n    abstract estimateGas(tx: ITransactionRequestConfig,): Promise<number>;\n    abstract encodeABI(): any;\n}","import { BaseContract } from \"../abstracts\";\nimport { ITransactionRequestConfig, ITransactionReceipt, ITransactionData, IBlock, IBlockWithTransaction, IJsonRpcRequestPayload, IJsonRpcResponse, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseWeb3Client {\n\n    constructor(public logger: Logger) {\n\n    }\n\n    abstract getContract(address: string, abi: any): BaseContract;\n\n    abstract read(config: ITransactionRequestConfig): Promise<string>;\n\n    abstract write(config: ITransactionRequestConfig): ITransactionWriteResult;\n    abstract getGasPrice(): Promise<string>;\n    abstract estimateGas(config: ITransactionRequestConfig): Promise<number>;\n    abstract getChainId(): Promise<number>;\n    abstract getTransactionCount(address: string, blockNumber: any): Promise<number>;\n\n    abstract getTransaction(transactionHash: string): Promise<ITransactionData>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<ITransactionReceipt>;\n    // abstract extend(property: string, methods: IMethod[])\n\n    abstract getBlock(blockHashOrBlockNumber): Promise<IBlock>;\n    abstract getBlockWithTransaction(blockHashOrBlockNumber): Promise<IBlockWithTransaction>;\n\n    getRootHash?(startBlock: number, endBlock: number) {\n        return this.sendRPCRequest({\n            jsonrpc: '2.0',\n            method: 'eth_getRootHash',\n            params: [Number(startBlock), Number(endBlock)],\n            id: new Date().getTime()\n        }).then(payload => {\n            return String(payload.result);\n        });\n    }\n\n    abstract sendRPCRequest(request: IJsonRpcRequestPayload): Promise<IJsonRpcResponse>;\n\n    abstract encodeParameters(params: any[], types: any[]): string;\n    abstract decodeParameters(hexString: string, types: any[]): any[];\n    abstract etheriumSha3(...value): string;\n\n}\n","import { BaseContractMethod } from \"../abstracts\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContract {\n\n    constructor(public address: string, public logger:Logger) {\n\n    }\n\n    abstract method(methodName: string, ...args): BaseContractMethod;\n}","import { throwNotImplemented } from \"..\";\n\nexport abstract class BaseBigNumber {\n    static isBN(value) {\n        return throwNotImplemented<boolean>();\n    }\n\n    abstract toString(): string;\n    abstract toNumber(): number;\n    abstract toBuffer(): Buffer;\n    abstract add(value: BaseBigNumber): BaseBigNumber;\n    abstract sub(value: BaseBigNumber): BaseBigNumber;\n    abstract mul(value: BaseBigNumber): BaseBigNumber;\n    abstract div(value: BaseBigNumber): BaseBigNumber;\n\n    abstract lte(value: BaseBigNumber): boolean;\n    abstract lt(value: BaseBigNumber): boolean;\n    abstract gte(value: BaseBigNumber): boolean;\n    abstract gt(value: BaseBigNumber): boolean;\n    abstract eq(value: BaseBigNumber): boolean;\n}","import { POSClient } from \"./pos\";\nimport { use, utils } from \"./utils\";\n\nexport const defaultExport = {\n    utils: utils,\n    use,\n    POSClient,\n};","module.exports = require(\"merkle-patricia-tree\");","module.exports = require(\"ethereumjs-tx\");","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chains_1 = require(\"./chains\");\nvar hardforks_1 = require(\"./hardforks\");\n/**\n * Common class to access chain and hardfork parameters\n */\nvar Common = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param chain String ('mainnet') or Number (1) chain\n     * @param hardfork String identifier ('byzantium') for hardfork (optional)\n     * @param supportedHardforks Limit parameter returns to the given hardforks (optional)\n     */\n    function Common(chain, hardfork, supportedHardforks) {\n        this._chainParams = this.setChain(chain);\n        this._hardfork = null;\n        this._supportedHardforks = supportedHardforks === undefined ? [] : supportedHardforks;\n        if (hardfork) {\n            this.setHardfork(hardfork);\n        }\n    }\n    /**\n     * Creates a Common object for a custom chain, based on a standard one. It uses all the [[Chain]]\n     * params from [[baseChain]] except the ones overridden in [[customChainParams]].\n     *\n     * @param baseChain The name (`mainnet`) or id (`1`) of a standard chain used to base the custom\n     * chain params on.\n     * @param customChainParams The custom parameters of the chain.\n     * @param hardfork String identifier ('byzantium') for hardfork (optional)\n     * @param supportedHardforks Limit parameter returns to the given hardforks (optional)\n     */\n    Common.forCustomChain = function (baseChain, customChainParams, hardfork, supportedHardforks) {\n        var standardChainParams = Common._getChainParams(baseChain);\n        return new Common(__assign(__assign({}, standardChainParams), customChainParams), hardfork, supportedHardforks);\n    };\n    Common._getChainParams = function (chain) {\n        if (typeof chain === 'number') {\n            if (chains_1.chains['names'][chain]) {\n                return chains_1.chains[chains_1.chains['names'][chain]];\n            }\n            throw new Error(\"Chain with ID \" + chain + \" not supported\");\n        }\n        if (chains_1.chains[chain]) {\n            return chains_1.chains[chain];\n        }\n        throw new Error(\"Chain with name \" + chain + \" not supported\");\n    };\n    /**\n     * Sets the chain\n     * @param chain String ('mainnet') or Number (1) chain\n     *     representation. Or, a Dictionary of chain parameters for a private network.\n     * @returns The dictionary with parameters set as chain\n     */\n    Common.prototype.setChain = function (chain) {\n        if (typeof chain === 'number' || typeof chain === 'string') {\n            this._chainParams = Common._getChainParams(chain);\n        }\n        else if (typeof chain === 'object') {\n            var required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n            for (var _i = 0, required_1 = required; _i < required_1.length; _i++) {\n                var param = required_1[_i];\n                if (chain[param] === undefined) {\n                    throw new Error(\"Missing required chain parameter: \" + param);\n                }\n            }\n            this._chainParams = chain;\n        }\n        else {\n            throw new Error('Wrong input format');\n        }\n        return this._chainParams;\n    };\n    /**\n     * Sets the hardfork to get params for\n     * @param hardfork String identifier ('byzantium')\n     */\n    Common.prototype.setHardfork = function (hardfork) {\n        if (!this._isSupportedHardfork(hardfork)) {\n            throw new Error(\"Hardfork \" + hardfork + \" not set as supported in supportedHardforks\");\n        }\n        var changed = false;\n        for (var _i = 0, hardforkChanges_1 = hardforks_1.hardforks; _i < hardforkChanges_1.length; _i++) {\n            var hfChanges = hardforkChanges_1[_i];\n            if (hfChanges[0] === hardfork) {\n                this._hardfork = hardfork;\n                changed = true;\n            }\n        }\n        if (!changed) {\n            throw new Error(\"Hardfork with name \" + hardfork + \" not supported\");\n        }\n    };\n    /**\n     * Internal helper function to choose between hardfork set and hardfork provided as param\n     * @param hardfork Hardfork given to function as a parameter\n     * @returns Hardfork chosen to be used\n     */\n    Common.prototype._chooseHardfork = function (hardfork, onlySupported) {\n        onlySupported = onlySupported === undefined ? true : onlySupported;\n        if (!hardfork) {\n            if (!this._hardfork) {\n                throw new Error('Method called with neither a hardfork set nor provided by param');\n            }\n            else {\n                hardfork = this._hardfork;\n            }\n        }\n        else if (onlySupported && !this._isSupportedHardfork(hardfork)) {\n            throw new Error(\"Hardfork \" + hardfork + \" not set as supported in supportedHardforks\");\n        }\n        return hardfork;\n    };\n    /**\n     * Internal helper function, returns the params for the given hardfork for the chain set\n     * @param hardfork Hardfork name\n     * @returns Dictionary with hardfork params\n     */\n    Common.prototype._getHardfork = function (hardfork) {\n        var hfs = this.hardforks();\n        for (var _i = 0, hfs_1 = hfs; _i < hfs_1.length; _i++) {\n            var hf = hfs_1[_i];\n            if (hf['name'] === hardfork)\n                return hf;\n        }\n        throw new Error(\"Hardfork \" + hardfork + \" not defined for chain \" + this.chainName());\n    };\n    /**\n     * Internal helper function to check if a hardfork is set to be supported by the library\n     * @param hardfork Hardfork name\n     * @returns True if hardfork is supported\n     */\n    Common.prototype._isSupportedHardfork = function (hardfork) {\n        if (this._supportedHardforks.length > 0) {\n            for (var _i = 0, _a = this._supportedHardforks; _i < _a.length; _i++) {\n                var supportedHf = _a[_i];\n                if (hardfork === supportedHf)\n                    return true;\n            }\n        }\n        else {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns the parameter corresponding to a hardfork\n     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow', 'casper', 'sharding')\n     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n     * @param hardfork Hardfork name, optional if hardfork set\n     */\n    Common.prototype.param = function (topic, name, hardfork) {\n        hardfork = this._chooseHardfork(hardfork);\n        var value;\n        for (var _i = 0, hardforkChanges_2 = hardforks_1.hardforks; _i < hardforkChanges_2.length; _i++) {\n            var hfChanges = hardforkChanges_2[_i];\n            if (!hfChanges[1][topic]) {\n                throw new Error(\"Topic \" + topic + \" not defined\");\n            }\n            if (hfChanges[1][topic][name] !== undefined) {\n                value = hfChanges[1][topic][name].v;\n            }\n            if (hfChanges[0] === hardfork)\n                break;\n        }\n        if (value === undefined) {\n            throw new Error(topic + \" value for \" + name + \" not found\");\n        }\n        return value;\n    };\n    /**\n     * Returns a parameter for the hardfork active on block number\n     * @param topic Parameter topic\n     * @param name Parameter name\n     * @param blockNumber Block number\n     */\n    Common.prototype.paramByBlock = function (topic, name, blockNumber) {\n        var activeHfs = this.activeHardforks(blockNumber);\n        var hardfork = activeHfs[activeHfs.length - 1]['name'];\n        return this.param(topic, name, hardfork);\n    };\n    /**\n     * Checks if set or provided hardfork is active on block number\n     * @param hardfork Hardfork name or null (for HF set)\n     * @param blockNumber\n     * @param opts Hardfork options (onlyActive unused)\n     * @returns True if HF is active on block number\n     */\n    Common.prototype.hardforkIsActiveOnBlock = function (hardfork, blockNumber, opts) {\n        opts = opts !== undefined ? opts : {};\n        var onlySupported = opts.onlySupported === undefined ? false : opts.onlySupported;\n        hardfork = this._chooseHardfork(hardfork, onlySupported);\n        var hfBlock = this.hardforkBlock(hardfork);\n        if (hfBlock !== null && blockNumber >= hfBlock)\n            return true;\n        return false;\n    };\n    /**\n     * Alias to hardforkIsActiveOnBlock when hardfork is set\n     * @param blockNumber\n     * @param opts Hardfork options (onlyActive unused)\n     * @returns True if HF is active on block number\n     */\n    Common.prototype.activeOnBlock = function (blockNumber, opts) {\n        return this.hardforkIsActiveOnBlock(null, blockNumber, opts);\n    };\n    /**\n     * Sequence based check if given or set HF1 is greater than or equal HF2\n     * @param hardfork1 Hardfork name or null (if set)\n     * @param hardfork2 Hardfork name\n     * @param opts Hardfork options\n     * @returns True if HF1 gte HF2\n     */\n    Common.prototype.hardforkGteHardfork = function (hardfork1, hardfork2, opts) {\n        opts = opts !== undefined ? opts : {};\n        var onlyActive = opts.onlyActive === undefined ? false : opts.onlyActive;\n        hardfork1 = this._chooseHardfork(hardfork1, opts.onlySupported);\n        var hardforks;\n        if (onlyActive) {\n            hardforks = this.activeHardforks(null, opts);\n        }\n        else {\n            hardforks = this.hardforks();\n        }\n        var posHf1 = -1, posHf2 = -1;\n        var index = 0;\n        for (var _i = 0, hardforks_2 = hardforks; _i < hardforks_2.length; _i++) {\n            var hf = hardforks_2[_i];\n            if (hf['name'] === hardfork1)\n                posHf1 = index;\n            if (hf['name'] === hardfork2)\n                posHf2 = index;\n            index += 1;\n        }\n        return posHf1 >= posHf2;\n    };\n    /**\n     * Alias to hardforkGteHardfork when hardfork is set\n     * @param hardfork Hardfork name\n     * @param opts Hardfork options\n     * @returns True if hardfork set is greater than hardfork provided\n     */\n    Common.prototype.gteHardfork = function (hardfork, opts) {\n        return this.hardforkGteHardfork(null, hardfork, opts);\n    };\n    /**\n     * Checks if given or set hardfork is active on the chain\n     * @param hardfork Hardfork name, optional if HF set\n     * @param opts Hardfork options (onlyActive unused)\n     * @returns True if hardfork is active on the chain\n     */\n    Common.prototype.hardforkIsActiveOnChain = function (hardfork, opts) {\n        opts = opts !== undefined ? opts : {};\n        var onlySupported = opts.onlySupported === undefined ? false : opts.onlySupported;\n        hardfork = this._chooseHardfork(hardfork, onlySupported);\n        for (var _i = 0, _a = this.hardforks(); _i < _a.length; _i++) {\n            var hf = _a[_i];\n            if (hf['name'] === hardfork && hf['block'] !== null)\n                return true;\n        }\n        return false;\n    };\n    /**\n     * Returns the active hardfork switches for the current chain\n     * @param blockNumber up to block if provided, otherwise for the whole chain\n     * @param opts Hardfork options (onlyActive unused)\n     * @return Array with hardfork arrays\n     */\n    Common.prototype.activeHardforks = function (blockNumber, opts) {\n        opts = opts !== undefined ? opts : {};\n        var activeHardforks = [];\n        var hfs = this.hardforks();\n        for (var _i = 0, hfs_2 = hfs; _i < hfs_2.length; _i++) {\n            var hf = hfs_2[_i];\n            if (hf['block'] === null)\n                continue;\n            if (blockNumber !== undefined && blockNumber !== null && blockNumber < hf['block'])\n                break;\n            if (opts.onlySupported && !this._isSupportedHardfork(hf['name']))\n                continue;\n            activeHardforks.push(hf);\n        }\n        return activeHardforks;\n    };\n    /**\n     * Returns the latest active hardfork name for chain or block or throws if unavailable\n     * @param blockNumber up to block if provided, otherwise for the whole chain\n     * @param opts Hardfork options (onlyActive unused)\n     * @return Hardfork name\n     */\n    Common.prototype.activeHardfork = function (blockNumber, opts) {\n        opts = opts !== undefined ? opts : {};\n        var activeHardforks = this.activeHardforks(blockNumber, opts);\n        if (activeHardforks.length > 0) {\n            return activeHardforks[activeHardforks.length - 1]['name'];\n        }\n        else {\n            throw new Error(\"No (supported) active hardfork found\");\n        }\n    };\n    /**\n     * Returns the hardfork change block for hardfork provided or set\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns Block number\n     */\n    Common.prototype.hardforkBlock = function (hardfork) {\n        hardfork = this._chooseHardfork(hardfork, false);\n        return this._getHardfork(hardfork)['block'];\n    };\n    /**\n     * True if block number provided is the hardfork (given or set) change block of the current chain\n     * @param blockNumber Number of the block to check\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns True if blockNumber is HF block\n     */\n    Common.prototype.isHardforkBlock = function (blockNumber, hardfork) {\n        hardfork = this._chooseHardfork(hardfork, false);\n        if (this.hardforkBlock(hardfork) === blockNumber) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Provide the consensus type for the hardfork set or provided as param\n     * @param hardfork Hardfork name, optional if hardfork set\n     * @returns Consensus type (e.g. 'pow', 'poa')\n     */\n    Common.prototype.consensus = function (hardfork) {\n        hardfork = this._chooseHardfork(hardfork);\n        return this._getHardfork(hardfork)['consensus'];\n    };\n    /**\n     * Provide the finality type for the hardfork set or provided as param\n     * @param {String} hardfork Hardfork name, optional if hardfork set\n     * @returns {String} Finality type (e.g. 'pos', null of no finality)\n     */\n    Common.prototype.finality = function (hardfork) {\n        hardfork = this._chooseHardfork(hardfork);\n        return this._getHardfork(hardfork)['finality'];\n    };\n    /**\n     * Returns the Genesis parameters of current chain\n     * @returns Genesis dictionary\n     */\n    Common.prototype.genesis = function () {\n        return this._chainParams['genesis'];\n    };\n    /**\n     * Returns the hardforks for current chain\n     * @returns {Array} Array with arrays of hardforks\n     */\n    Common.prototype.hardforks = function () {\n        return this._chainParams['hardforks'];\n    };\n    /**\n     * Returns bootstrap nodes for the current chain\n     * @returns {Dictionary} Dict with bootstrap nodes\n     */\n    Common.prototype.bootstrapNodes = function () {\n        return this._chainParams['bootstrapNodes'];\n    };\n    /**\n     * Returns the hardfork set\n     * @returns Hardfork name\n     */\n    Common.prototype.hardfork = function () {\n        return this._hardfork;\n    };\n    /**\n     * Returns the Id of current chain\n     * @returns chain Id\n     */\n    Common.prototype.chainId = function () {\n        return this._chainParams['chainId'];\n    };\n    /**\n     * Returns the name of current chain\n     * @returns chain name (lower case)\n     */\n    Common.prototype.chainName = function () {\n        return chains_1.chains['names'][this.chainId()] || this._chainParams['name'];\n    };\n    /**\n     * Returns the Id of current network\n     * @returns network Id\n     */\n    Common.prototype.networkId = function () {\n        return this._chainParams['networkId'];\n    };\n    return Common;\n}());\nexports.default = Common;\n//# sourceMappingURL=index.js.map","const Common = require('ethereumjs-common').default\nconst utils = require('ethereumjs-util')\nconst BN = utils.BN\n  /**\n   * An object that repersents the block header\n   * @constructor\n   * @param {Array} data raw data, deserialized\n   * @param {Array} opts Options\n   * @param {String|Number} opts.chain The chain for the block header [default: 'mainnet']\n   * @param {String} opts.hardfork Hardfork for the block header [default: null, block number-based behaviour]\n   * @param {Object} opts.common Alternatively pass a Common instance instead of setting chain/hardfork directly\n   * @prop {Buffer} parentHash the blocks' parent's hash\n   * @prop {Buffer} uncleHash sha3(rlp_encode(uncle_list))\n   * @prop {Buffer} coinbase the miner address\n   * @prop {Buffer} stateRoot The root of a Merkle Patricia tree\n   * @prop {Buffer} transactionTrie the root of a Trie containing the transactions\n   * @prop {Buffer} receiptTrie the root of a Trie containing the transaction Reciept\n   * @prop {Buffer} bloom\n   * @prop {Buffer} difficulty\n   * @prop {Buffer} number the block's height\n   * @prop {Buffer} gasLimit\n   * @prop {Buffer} gasUsed\n   * @prop {Buffer} timestamp\n   * @prop {Buffer} extraData\n   * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n   */\nvar BlockHeader = module.exports = function (data, opts) {\n  opts = opts || {}\n\n  if (opts.common) {\n    if (opts.chain) {\n      throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!')\n    }\n    this._common = opts.common\n  } else {\n    let chain = opts.chain ? opts.chain : 'mainnet'\n    let hardfork = opts.hardfork ? opts.hardfork : null\n    this._common = new Common(chain, hardfork)\n  }\n\n  var fields = [{\n    name: 'parentHash',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'uncleHash',\n    default: utils.SHA3_RLP_ARRAY\n  }, {\n    name: 'coinbase',\n    length: 20,\n    default: utils.zeros(20)\n  }, {\n    name: 'stateRoot',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'transactionsTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'receiptTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'bloom',\n    default: utils.zeros(256)\n  }, {\n    name: 'difficulty',\n    default: Buffer.from([])\n  }, {\n    name: 'number',\n    // TODO: params.homeSteadForkNumber.v left for legacy reasons, replace on future release\n    default: utils.intToBuffer(1150000)\n  }, {\n    name: 'gasLimit',\n    default: Buffer.from('ffffffffffffff', 'hex')\n  }, {\n    name: 'gasUsed',\n    empty: true,\n    default: Buffer.from([])\n  }, {\n    name: 'timestamp',\n    default: Buffer.from([])\n  }, {\n    name: 'extraData',\n    allowZero: true,\n    empty: true,\n    default: Buffer.from([])\n  }, {\n    name: 'mixHash',\n    default: utils.zeros(32)\n      // length: 32\n  }, {\n    name: 'nonce',\n    default: utils.zeros(8) // sha3(42)\n  }]\n  utils.defineProperties(this, fields, data)\n}\n\n/**\n * Returns the canoncical difficulty of the block\n * @method canonicalDifficulty\n * @param {Block} parentBlock the parent `Block` of the this header\n * @return {BN}\n */\nBlockHeader.prototype.canonicalDifficulty = function (parentBlock) {\n  const hardfork = this._common.hardfork() || this._common.activeHardfork(utils.bufferToInt(this.number))\n  const blockTs = new BN(this.timestamp)\n  const parentTs = new BN(parentBlock.header.timestamp)\n  const parentDif = new BN(parentBlock.header.difficulty)\n  const minimumDifficulty = new BN(this._common.param('pow', 'minimumDifficulty', hardfork))\n  var offset = parentDif.div(new BN(this._common.param('pow', 'difficultyBoundDivisor', hardfork)))\n  var num = new BN(this.number)\n  var a\n  var cutoff\n  var dif\n\n  if (this._common.hardforkGteHardfork(hardfork, 'byzantium')) {\n    // max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99) (EIP100)\n    var uncleAddend = parentBlock.header.uncleHash.equals(utils.SHA3_RLP_ARRAY) ? 1 : 2\n    a = blockTs.sub(parentTs).idivn(9).ineg().iaddn(uncleAddend)\n    cutoff = new BN(-99)\n    // MAX(cutoff, a)\n    if (cutoff.cmp(a) === 1) {\n      a = cutoff\n    }\n    dif = parentDif.add(offset.mul(a))\n  }\n\n  if (this._common.hardforkGteHardfork(hardfork, 'constantinople')) {\n    // Constantinople difficulty bomb delay (EIP1234)\n    num.isubn(5000000)\n    if (num.ltn(0)) {\n      num = new BN(0)\n    }\n  } else if (this._common.hardforkGteHardfork(hardfork, 'byzantium')) {\n    // Byzantium difficulty bomb delay (EIP649)\n    num.isubn(3000000)\n    if (num.ltn(0)) {\n      num = new BN(0)\n    }\n  } else if (this._common.hardforkGteHardfork(hardfork, 'homestead')) {\n    // 1 - (block_timestamp - parent_timestamp) // 10\n    a = blockTs.sub(parentTs).idivn(10).ineg().iaddn(1)\n    cutoff = new BN(-99)\n    // MAX(cutoff, a)\n    if (cutoff.cmp(a) === 1) {\n      a = cutoff\n    }\n    dif = parentDif.add(offset.mul(a))\n  } else {\n    // pre-homestead\n    if (parentTs.addn(this._common.param('pow', 'durationLimit', hardfork)).cmp(blockTs) === 1) {\n      dif = offset.add(parentDif)\n    } else {\n      dif = parentDif.sub(offset)\n    }\n  }\n\n  var exp = num.idivn(100000).isubn(2)\n  if (!exp.isNeg()) {\n    dif.iadd(new BN(2).pow(exp))\n  }\n\n  if (dif.cmp(minimumDifficulty) === -1) {\n    dif = minimumDifficulty\n  }\n\n  return dif\n}\n\n/**\n * checks that the block's `difficuly` matches the canonical difficulty\n * @method validateDifficulty\n * @param {Block} parentBlock this block's parent\n * @return {Boolean}\n */\nBlockHeader.prototype.validateDifficulty = function (parentBlock) {\n  const dif = this.canonicalDifficulty(parentBlock)\n  return dif.cmp(new BN(this.difficulty)) === 0\n}\n\n/**\n * Validates the gasLimit\n * @method validateGasLimit\n * @param {Block} parentBlock this block's parent\n * @returns {Boolean}\n */\nBlockHeader.prototype.validateGasLimit = function (parentBlock) {\n  const pGasLimit = new BN(parentBlock.header.gasLimit)\n  const gasLimit = new BN(this.gasLimit)\n  const hardfork = this._common.hardfork() ? this._common.hardfork() : this._common.activeHardfork(this.number)\n  const a = pGasLimit.div(new BN(this._common.param('gasConfig', 'gasLimitBoundDivisor', hardfork)))\n  const maxGasLimit = pGasLimit.add(a)\n  const minGasLimit = pGasLimit.sub(a)\n\n  return gasLimit.lt(maxGasLimit) && gasLimit.gt(minGasLimit) && gasLimit.gte(this._common.param('gasConfig', 'minGasLimit', hardfork))\n}\n\n/**\n * Validates the entire block header\n * @method validate\n * @param {Blockchain} blockChain the blockchain that this block is validating against\n * @param {Bignum} [height] if this is an uncle header, this is the height of the block that is including it\n * @param {Function} cb the callback function. The callback is given an `error` if the block is invalid\n */\nBlockHeader.prototype.validate = function (blockchain, height, cb) {\n  var self = this\n  if (arguments.length === 2) {\n    cb = height\n    height = false\n  }\n\n  if (this.isGenesis()) {\n    return cb()\n  }\n\n  // find the blocks parent\n  blockchain.getBlock(self.parentHash, function (err, parentBlock) {\n    if (err) {\n      return cb('could not find parent block')\n    }\n\n    self.parentBlock = parentBlock\n\n    var number = new BN(self.number)\n    if (number.cmp(new BN(parentBlock.header.number).iaddn(1)) !== 0) {\n      return cb('invalid number')\n    }\n\n    if (height) {\n      var dif = height.sub(new BN(parentBlock.header.number))\n      if (!(dif.cmpn(8) === -1 && dif.cmpn(1) === 1)) {\n        return cb('uncle block has a parent that is too old or to young')\n      }\n    }\n\n    if (!self.validateDifficulty(parentBlock)) {\n      return cb('invalid Difficulty')\n    }\n\n    if (!self.validateGasLimit(parentBlock)) {\n      return cb('invalid gas limit')\n    }\n\n    if (utils.bufferToInt(parentBlock.header.number) + 1 !== utils.bufferToInt(self.number)) {\n      return cb('invalid heigth')\n    }\n\n    if (utils.bufferToInt(self.timestamp) <= utils.bufferToInt(parentBlock.header.timestamp)) {\n      return cb('invalid timestamp')\n    }\n\n    const hardfork = self._common.hardfork() ? self._common.hardfork() : self._common.activeHardfork(height)\n    if (self.extraData.length > self._common.param('vm', 'maxExtraDataSize', hardfork)) {\n      return cb('invalid amount of extra data')\n    }\n\n    cb()\n  })\n}\n\n/**\n * Returns the sha3 hash of the blockheader\n * @method hash\n * @return {Buffer}\n */\nBlockHeader.prototype.hash = function () {\n  return utils.rlphash(this.raw)\n}\n\n/**\n * checks if the blockheader is a genesis header\n * @method isGenesis\n * @return {Boolean}\n */\nBlockHeader.prototype.isGenesis = function () {\n  return this.number.toString('hex') === ''\n}\n\n/**\n * turns the header into the canonical genesis block header\n * @method setGenesisParams\n */\nBlockHeader.prototype.setGenesisParams = function () {\n  this.timestamp = this._common.genesis().timestamp\n  this.gasLimit = this._common.genesis().gasLimit\n  this.difficulty = this._common.genesis().difficulty\n  this.extraData = this._common.genesis().extraData\n  this.nonce = this._common.genesis().nonce\n  this.stateRoot = this._common.genesis().stateRoot\n  this.number = Buffer.from([])\n}\n","export * from \"./plugin\";\nexport * from \"./method\";\nexport * from \"./transaction_config\";\nexport * from \"./transaction_write_result\";\nexport * from \"./transaction_result\";\nexport * from \"./transaction_option\";\nexport * from \"./contract_init_param\";\nexport * from \"./tx_receipt\";\nexport * from \"./pos_client_config\";\nexport * from \"./transaction_data\";\nexport * from \"./block\";\nexport * from \"./block_with_transaction\";\nexport * from \"./rpc_request_payload\";\nexport * from \"./rpc_response_payload\";\nexport * from \"./map_promise_option\";\nexport * from \"./base_client_config\";\nexport * from \"./error\";\nexport * from \"./pos_contracts\";\nexport * from \"./root_block_info\";\nexport * from \"./allowance_transaction_option\";\nexport * from \"./approve_transaction_option\";","import { BaseBigNumber } from \"../abstracts\";\n\nexport * from \"./pos_erc1155_deposit_param\";\nexport * from \"./pos_erc1155_transfer_param\";\n\nexport type TYPE_AMOUNT = BaseBigNumber | string | number;","export const MAX_AMOUNT = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\n","'use strict'\nconst Transaction = require('ethereumjs-tx')\nconst ethUtil = require('ethereumjs-util')\nconst Block = require('./')\nconst blockHeaderFromRpc = require('./header-from-rpc')\n\nmodule.exports = blockFromRpc\n\n/**\n * Creates a new block object from Ethereum JSON RPC.\n * @param {Object} blockParams - Ethereum JSON RPC of block (eth_getBlockByNumber)\n * @param {Array.<Object>} Optional list of Ethereum JSON RPC of uncles (eth_getUncleByBlockHashAndIndex)\n */\nfunction blockFromRpc (blockParams, uncles) {\n  uncles = uncles || []\n  const block = new Block({\n    transactions: [],\n    uncleHeaders: []\n  })\n  block.header = blockHeaderFromRpc(blockParams)\n\n  block.transactions = (blockParams.transactions || []).map(function (_txParams) {\n    const txParams = normalizeTxParams(_txParams)\n    // override from address\n    const fromAddress = ethUtil.toBuffer(txParams.from)\n    delete txParams.from\n    const tx = new Transaction(txParams)\n    tx._from = fromAddress\n    tx.getSenderAddress = function () { return fromAddress }\n    // override hash\n    const txHash = ethUtil.toBuffer(txParams.hash)\n    tx.hash = function () { return txHash }\n    return tx\n  })\n  block.uncleHeaders = uncles.map(function (uncleParams) {\n    return blockHeaderFromRpc(uncleParams)\n  })\n\n  return block\n}\n\nfunction normalizeTxParams (_txParams) {\n  const txParams = Object.assign({}, _txParams)\n  // hot fix for https://github.com/ethereumjs/ethereumjs-util/issues/40\n  txParams.gasLimit = (txParams.gasLimit === undefined) ? txParams.gas : txParams.gasLimit\n  txParams.data = (txParams.data === undefined) ? txParams.input : txParams.data\n  // strict byte length checking\n  txParams.to = txParams.to ? ethUtil.setLengthLeft(ethUtil.toBuffer(txParams.to), 20) : null\n  // v as raw signature value {0,1}\n  txParams.v = txParams.v < 27 ? txParams.v + 27 : txParams.v\n  return txParams\n}\n","module.exports = require(\"buffer\");","const Common = require('ethereumjs-common').default\nconst ethUtil = require('ethereumjs-util')\nconst Tx = require('ethereumjs-tx')\nconst Trie = require('merkle-patricia-tree')\nconst BN = ethUtil.BN\nconst rlp = ethUtil.rlp\nconst async = require('async')\nconst BlockHeader = require('./header')\n\n/**\n * Creates a new block object\n * @constructor the raw serialized or the deserialized block.\n * @param {Array|Buffer|Object} data\n * @param {Array} opts Options\n * @param {String|Number} opts.chain The chain for the block [default: 'mainnet']\n * @param {String} opts.hardfork Hardfork for the block [default: null, block number-based behaviour]\n * @param {Object} opts.common Alternatively pass a Common instance (ethereumjs-common) instead of setting chain/hardfork directly\n * @prop {Header} header the block's header\n * @prop {Array.<Header>} uncleList an array of uncle headers\n * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n */\nvar Block = module.exports = function (data, opts) {\n  opts = opts || {}\n\n  if (opts.common) {\n    if (opts.chain) {\n      throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!')\n    }\n    this._common = opts.common\n  } else {\n    let chain = opts.chain ? opts.chain : 'mainnet'\n    let hardfork = opts.hardfork ? opts.hardfork : null\n    this._common = new Common(chain, hardfork)\n  }\n\n  this.transactions = []\n  this.uncleHeaders = []\n  this._inBlockChain = false\n  this.txTrie = new Trie()\n\n  Object.defineProperty(this, 'raw', {\n    get: function () {\n      return this.serialize(false)\n    }\n  })\n\n  var rawTransactions, rawUncleHeaders\n\n  // defaults\n  if (!data) {\n    data = [[], [], []]\n  }\n\n  if (Buffer.isBuffer(data)) {\n    data = rlp.decode(data)\n  }\n\n  if (Array.isArray(data)) {\n    this.header = new BlockHeader(data[0], opts)\n    rawTransactions = data[1]\n    rawUncleHeaders = data[2]\n  } else {\n    this.header = new BlockHeader(data.header, opts)\n    rawTransactions = data.transactions || []\n    rawUncleHeaders = data.uncleHeaders || []\n  }\n\n  // parse uncle headers\n  for (var i = 0; i < rawUncleHeaders.length; i++) {\n    this.uncleHeaders.push(new BlockHeader(rawUncleHeaders[i], opts))\n  }\n\n  // parse transactions\n  for (i = 0; i < rawTransactions.length; i++) {\n    var tx = new Tx(rawTransactions[i])\n    tx._homestead = true\n    this.transactions.push(tx)\n  }\n}\n\nBlock.Header = BlockHeader\n\n/**\n * Produces a hash the RLP of the block\n * @method hash\n */\nBlock.prototype.hash = function () {\n  return this.header.hash()\n}\n\n/**\n * Determines if a given block is the genesis block\n * @method isGenisis\n * @return Boolean\n */\nBlock.prototype.isGenesis = function () {\n  return this.header.isGenesis()\n}\n\n/**\n * turns the block into the canonical genesis block\n * @method setGenesisParams\n */\nBlock.prototype.setGenesisParams = function () {\n  this.header.setGenesisParams()\n}\n\n/**\n * Produces a serialization of the block.\n * @method serialize\n * @param {Boolean} rlpEncode whether to rlp encode the block or not\n */\nBlock.prototype.serialize = function (rlpEncode) {\n  var raw = [this.header.raw, [],\n    []\n  ]\n\n  // rlpEnode defaults to true\n  if (typeof rlpEncode === 'undefined') {\n    rlpEncode = true\n  }\n\n  this.transactions.forEach(function (tx) {\n    raw[1].push(tx.raw)\n  })\n\n  this.uncleHeaders.forEach(function (uncle) {\n    raw[2].push(uncle.raw)\n  })\n\n  return rlpEncode ? rlp.encode(raw) : raw\n}\n\n/**\n * Generate transaction trie. The tx trie must be generated before the transaction trie can\n * be validated with `validateTransactionTrie`\n * @method genTxTrie\n * @param {Function} cb the callback\n */\nBlock.prototype.genTxTrie = function (cb) {\n  var i = 0\n  var self = this\n\n  async.eachSeries(this.transactions, function (tx, done) {\n    self.txTrie.put(rlp.encode(i), tx.serialize(), done)\n    i++\n  }, cb)\n}\n\n/**\n * Validates the transaction trie\n * @method validateTransactionTrie\n * @return {Boolean}\n */\nBlock.prototype.validateTransactionsTrie = function () {\n  var txT = this.header.transactionsTrie.toString('hex')\n  if (this.transactions.length) {\n    return txT === this.txTrie.root.toString('hex')\n  } else {\n    return txT === ethUtil.SHA3_RLP.toString('hex')\n  }\n}\n\n/**\n * Validates the transactions\n * @method validateTransactions\n * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean\n * @return {Boolean}\n */\nBlock.prototype.validateTransactions = function (stringError) {\n  var errors = []\n\n  this.transactions.forEach(function (tx, i) {\n    var error = tx.validate(true)\n    if (error) {\n      errors.push(error + ' at tx ' + i)\n    }\n  })\n\n  if (stringError === undefined || stringError === false) {\n    return errors.length === 0\n  } else {\n    return arrayToString(errors)\n  }\n}\n\n/**\n * Validates the entire block. Returns a string to the callback if block is invalid\n * @method validate\n * @param {BlockChain} blockChain the blockchain that this block wants to be part of\n * @param {Function} cb the callback which is given a `String` if the block is not valid\n */\nBlock.prototype.validate = function (blockChain, cb) {\n  var self = this\n  var errors = []\n\n  async.parallel([\n    // validate uncles\n    self.validateUncles.bind(self, blockChain),\n    // validate block\n    self.header.validate.bind(self.header, blockChain),\n    // generate the transaction trie\n    self.genTxTrie.bind(self)\n  ], function (err) {\n    if (err) {\n      errors.push(err)\n    }\n\n    if (!self.validateTransactionsTrie()) {\n      errors.push('invalid transaction trie')\n    }\n\n    var txErrors = self.validateTransactions(true)\n    if (txErrors !== '') {\n      errors.push(txErrors)\n    }\n\n    if (!self.validateUnclesHash()) {\n      errors.push('invalid uncle hash')\n    }\n\n    cb(arrayToString(errors))\n  })\n}\n\n/**\n * Validates the uncle's hash\n * @method validateUncleHash\n * @return {Boolean}\n */\nBlock.prototype.validateUnclesHash = function () {\n  var raw = []\n  this.uncleHeaders.forEach(function (uncle) {\n    raw.push(uncle.raw)\n  })\n\n  raw = rlp.encode(raw)\n  return ethUtil.sha3(raw).toString('hex') === this.header.uncleHash.toString('hex')\n}\n\n/**\n * Validates the uncles that are in the block if any. Returns a string to the callback if uncles are invalid\n * @method validateUncles\n * @param {Blockchain} blockChaina an instance of the Blockchain\n * @param {Function} cb the callback\n */\nBlock.prototype.validateUncles = function (blockChain, cb) {\n  if (this.isGenesis()) {\n    return cb()\n  }\n\n  var self = this\n\n  if (self.uncleHeaders.length > 2) {\n    return cb('too many uncle headers')\n  }\n\n  var uncleHashes = self.uncleHeaders.map(function (header) {\n    return header.hash().toString('hex')\n  })\n\n  if (!((new Set(uncleHashes)).size === uncleHashes.length)) {\n    return cb('duplicate uncles')\n  }\n\n  async.each(self.uncleHeaders, function (uncle, cb2) {\n    var height = new BN(self.header.number)\n    async.parallel([\n      uncle.validate.bind(uncle, blockChain, height),\n      // check to make sure the uncle is not already in the blockchain\n      function (cb3) {\n        blockChain.getDetails(uncle.hash(), function (err, blockInfo) {\n          // TODO: remove uncles from BC\n          if (blockInfo && blockInfo.isUncle) {\n            cb3(err || 'uncle already included')\n          } else {\n            cb3()\n          }\n        })\n      }\n    ], cb2)\n  }, cb)\n}\n\n/**\n * Converts the block toJSON\n * @method toJSON\n * @param {Bool} labeled whether to create an labeled object or an array\n * @return {Object}\n */\nBlock.prototype.toJSON = function (labeled) {\n  if (labeled) {\n    var obj = {\n      header: this.header.toJSON(true),\n      transactions: [],\n      uncleHeaders: []\n    }\n\n    this.transactions.forEach(function (tx) {\n      obj.transactions.push(tx.toJSON(labeled))\n    })\n\n    this.uncleHeaders.forEach(function (uh) {\n      obj.uncleHeaders.push(uh.toJSON())\n    })\n    return obj\n  } else {\n    return ethUtil.baToJSON(this.raw)\n  }\n}\n\nfunction arrayToString (array) {\n  try {\n    return array.reduce(function (str, err) {\n      if (str) {\n        str += ' '\n      }\n      return str + err\n    })\n  } catch (e) {\n    return ''\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chains = void 0;\nexports.chains = {\n    names: {\n        '1': 'mainnet',\n        '3': 'ropsten',\n        '4': 'rinkeby',\n        '42': 'kovan',\n        '5': 'goerli',\n    },\n    mainnet: require('./mainnet.json'),\n    ropsten: require('./ropsten.json'),\n    rinkeby: require('./rinkeby.json'),\n    kovan: require('./kovan.json'),\n    goerli: require('./goerli.json'),\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hardforks = void 0;\nexports.hardforks = [\n    ['chainstart', require('./chainstart.json')],\n    ['homestead', require('./homestead.json')],\n    ['dao', require('./dao.json')],\n    ['tangerineWhistle', require('./tangerineWhistle.json')],\n    ['spuriousDragon', require('./spuriousDragon.json')],\n    ['byzantium', require('./byzantium.json')],\n    ['constantinople', require('./constantinople.json')],\n    ['petersburg', require('./petersburg.json')],\n    ['istanbul', require('./istanbul.json')],\n    ['muirGlacier', require('./muirGlacier.json')],\n];\n//# sourceMappingURL=index.js.map","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction slice(arrayLike, start) {\n    start = start|0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for(var idx = 0; idx < newLen; idx++)  {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply = function(fn/*, ...args*/) {\n    var args = slice(arguments, 1);\n    return function(/*callArgs*/) {\n        var callArgs = slice(arguments);\n        return fn.apply(null, args.concat(callArgs));\n    };\n};\n\nvar initialParams = function (fn) {\n    return function (/*...args, callback*/) {\n        var args = slice(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function(value) {\n                invokeCallback(callback, null, value);\n            }, function(err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        setImmediate$1(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nfunction applyEach$1(eachfn) {\n    return function(fns/*, ...args*/) {\n        var args = slice(arguments, 1);\n        var go = initialParams(function(args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? {value: obj[key], key: key} : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function() {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(function(err, result) {\n            runningTasks--;\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function(val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg){\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function(node) {\n    if (node.prev) node.prev.next = node.next;\n    else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;\n    else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = function () {\n    while(this.head) this.shift();\n    return this;\n};\n\nDLL.prototype.insertAfter = function(node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;\n    else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;\n    else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function(node) {\n    if (this.head) this.insertBefore(this.head, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.push = function(node) {\n    if (this.tail) this.insertAfter(this.tail, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.shift = function() {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function() {\n    return this.tail && this.removeLink(this.tail);\n};\n\nDLL.prototype.toArray = function () {\n    var arr = Array(this.length);\n    var curr = this.head;\n    for(var idx = 0; idx < this.length; idx++) {\n        arr[idx] = curr.data;\n        curr = curr.next;\n    }\n    return arr;\n};\n\nDLL.prototype.remove = function (testFn) {\n    var curr = this.head;\n    while(!!curr) {\n        var next = curr.next;\n        if (testFn(curr)) {\n            this.removeLink(curr);\n        }\n        curr = next;\n    }\n    return this;\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(function() {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n    }\n\n    function _next(tasks) {\n        return function(err){\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = baseIndexOf(workersList, task, 0);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback.apply(task, arguments);\n\n                if (err != null) {\n                    q.error(err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        };\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated:noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        remove: function (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    eachOfSeries(coll, function(x, i, callback) {\n        _iteratee(memo, x, function(err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function(err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(/*...functions*/) {\n    var _functions = arrayMap(arguments, wrapAsync);\n    return function(/*...args*/) {\n        var args = slice(arguments);\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function(newargs, fn, cb) {\n            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {\n                var nextargs = slice(arguments, 1);\n                cb(err, nextargs);\n            }));\n        },\n        function(err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = function(/*...args*/) {\n    return seq.apply(null, slice(arguments).reverse());\n};\n\nvar _concat = Array.prototype.concat;\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err /*, ...args*/) {\n            if (err) return callback(err);\n            return callback(null, slice(arguments, 1));\n        });\n    }, function(err, mapResults) {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = _concat.apply(result, mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doLimit(concatLimit, Infinity);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doLimit(concatLimit, 1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = function(/*...values*/) {\n    var values = slice(arguments);\n    var args = [null].concat(values);\n    return function (/*...ignoredArgs, callback*/) {\n        var callback = arguments[arguments.length - 1];\n        return callback.apply(this, args);\n    };\n};\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nfunction _createTester(check, getResult) {\n    return function(eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function(value, _, callback) {\n            iteratee(value, function(err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function(err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        args.push(function (err/*, ...args*/) {\n            var args = slice(arguments, 1);\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        });\n        wrapAsync(fn).apply(null, args);\n    };\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        args.push(check);\n        _test.apply(this, args);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function() {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err, key) {\n            if (err) return callback(err);\n            return callback(null, {key: key, val: val});\n        });\n    }, function(err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    eachOfLimit(obj, limit, function(val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function() {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(function(/*args*/) {\n                var args = slice(arguments);\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            }));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync(task)(function (err, result) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            results[key] = result;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n    _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n    _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue(function (items, cb) {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = slice(array).reverse();\n    reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(function callback(error, cbArg) {\n            if (error) {\n                reflectCallback(null, { error: error });\n            } else {\n                var value;\n                if (arguments.length <= 2) {\n                    value = cbArg;\n                } else {\n                    value = slice(arguments, 1);\n                }\n                reflectCallback(null, { value: value });\n            }\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function(task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function(value, cb) {\n        iteratee(value, function(err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function(err) {\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n    _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, {value: x, criteria: criteria});\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams(function (args, callback) {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push(function () {\n            if (!timedOut) {\n                callback.apply(null, arguments);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args);\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf(coll, function(v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function(err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    callback = callback || noop;\n    eachSeries(tasks, function(task, callback) {\n        wrapAsync(task)(function (err, res/*, ...args*/) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            } else {\n                result = res;\n            }\n            error = err;\n            callback(!err);\n        });\n    }, function () {\n        callback(error, result);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    if (!test()) return callback(null);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        var args = slice(arguments, 1);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function() {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        args.push(onlyOnce(next));\n        task.apply(null, args);\n    }\n\n    function next(err/*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask(slice(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n    apply: apply,\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    asyncify: asyncify,\n    auto: auto,\n    autoInject: autoInject,\n    cargo: cargo,\n    compose: compose,\n    concat: concat,\n    concatLimit: concatLimit,\n    concatSeries: concatSeries,\n    constant: constant,\n    detect: detect,\n    detectLimit: detectLimit,\n    detectSeries: detectSeries,\n    dir: dir,\n    doDuring: doDuring,\n    doUntil: doUntil,\n    doWhilst: doWhilst,\n    during: during,\n    each: eachLimit,\n    eachLimit: eachLimit$1,\n    eachOf: eachOf,\n    eachOfLimit: eachOfLimit,\n    eachOfSeries: eachOfSeries,\n    eachSeries: eachSeries,\n    ensureAsync: ensureAsync,\n    every: every,\n    everyLimit: everyLimit,\n    everySeries: everySeries,\n    filter: filter,\n    filterLimit: filterLimit,\n    filterSeries: filterSeries,\n    forever: forever,\n    groupBy: groupBy,\n    groupByLimit: groupByLimit,\n    groupBySeries: groupBySeries,\n    log: log,\n    map: map,\n    mapLimit: mapLimit,\n    mapSeries: mapSeries,\n    mapValues: mapValues,\n    mapValuesLimit: mapValuesLimit,\n    mapValuesSeries: mapValuesSeries,\n    memoize: memoize,\n    nextTick: nextTick,\n    parallel: parallelLimit,\n    parallelLimit: parallelLimit$1,\n    priorityQueue: priorityQueue,\n    queue: queue$1,\n    race: race,\n    reduce: reduce,\n    reduceRight: reduceRight,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    reject: reject,\n    rejectLimit: rejectLimit,\n    rejectSeries: rejectSeries,\n    retry: retry,\n    retryable: retryable,\n    seq: seq,\n    series: series,\n    setImmediate: setImmediate$1,\n    some: some,\n    someLimit: someLimit,\n    someSeries: someSeries,\n    sortBy: sortBy,\n    timeout: timeout,\n    times: times,\n    timesLimit: timeLimit,\n    timesSeries: timesSeries,\n    transform: transform,\n    tryEach: tryEach,\n    unmemoize: unmemoize,\n    until: until,\n    waterfall: waterfall,\n    whilst: whilst,\n\n    // aliases\n    all: every,\n    allLimit: everyLimit,\n    allSeries: everySeries,\n    any: some,\n    anyLimit: someLimit,\n    anySeries: someSeries,\n    find: detect,\n    findLimit: detectLimit,\n    findSeries: detectSeries,\n    forEach: eachLimit,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit$1,\n    forEachOf: eachOf,\n    forEachOfSeries: eachOfSeries,\n    forEachOfLimit: eachOfLimit,\n    inject: reduce,\n    foldl: reduce,\n    foldr: reduceRight,\n    select: filter,\n    selectLimit: filterLimit,\n    selectSeries: filterSeries,\n    wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.apply = apply;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatLimit = concatLimit;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.tryEach = tryEach;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","'use strict'\nconst BlockHeader = require('./header')\nconst ethUtil = require('ethereumjs-util')\n\nmodule.exports = blockHeaderFromRpc\n\n/**\n * Creates a new block header object from Ethereum JSON RPC.\n * @param {Object} blockParams - Ethereum JSON RPC of block (eth_getBlockByNumber)\n */\nfunction blockHeaderFromRpc (blockParams) {\n  const blockHeader = new BlockHeader({\n    parentHash: blockParams.parentHash,\n    uncleHash: blockParams.sha3Uncles,\n    coinbase: blockParams.miner,\n    stateRoot: blockParams.stateRoot,\n    transactionsTrie: blockParams.transactionsRoot,\n    receiptTrie: blockParams.receiptRoot || blockParams.receiptsRoot || ethUtil.SHA3_NULL,\n    bloom: blockParams.logsBloom,\n    difficulty: blockParams.difficulty,\n    number: blockParams.number,\n    gasLimit: blockParams.gasLimit,\n    gasUsed: blockParams.gasUsed,\n    timestamp: blockParams.timestamp,\n    extraData: blockParams.extraData,\n    mixHash: blockParams.mixHash,\n    nonce: blockParams.nonce\n  })\n\n  // override hash incase something was missing\n  blockHeader.hash = function () {\n    return ethUtil.toBuffer(blockParams.hash)\n  }\n\n  return blockHeader\n}\n","module.exports = require(\"node-fetch\");"],"sourceRoot":""}